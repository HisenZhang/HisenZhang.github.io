<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>海森的博客</title>
    <link>https://hisenz.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>海森的博客 - 技术, 料理 &amp; 爵士乐</description>
    <pubDate>Sun, 26 May 2019 13:54:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>料理 | 鸡腿排练习</title>
      <link>https://hisenz.com/post/fried-chicken-2/</link>
      <guid>https://hisenz.com/post/fried-chicken-2/</guid>
      <pubDate>Sun, 26 May 2019 12:47:19 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;料理 | 鸡腿排练习&quot;&gt;&lt;p&gt;继上次的&lt;a href=&quot;/post/fried-chicken&quot;&gt;完美鸡腿排指南&lt;/a&gt;, 这一次的练习做出了一些改进.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="料理 | 鸡腿排练习"><p>继上次的<a href="/post/fried-chicken">完美鸡腿排指南</a>, 这一次的练习做出了一些改进.</p><a id="more"></a><h2 id="复炸"><a href="#复炸" class="headerlink" title="复炸"></a>复炸</h2><p>上一次我采取了一次油炸的方式制作的鸡排, 外观看上去颜色较深. 为了解决这一问题, 这一次在炸制时候选择了更低的温度, 并且在开始呈现出金黄色的时候捞出, 重新裹粉并冷却. 随后提升油温, 较快的在油里过一遍, 捞起控油.</p><p>这里放两张图片作为对比</p><p><img src="https://s2.ax1x.com/2019/05/04/EdXE9K.jpg" alt=""></p><blockquote><p>一次油炸</p></blockquote><p><img src="https://s2.ax1x.com/2019/05/26/VVuuZj.jpg" alt=""></p><blockquote><p>二次油炸(复炸)</p></blockquote><p>可见复炸可以有效解决解决焦黑的问题.</p><p>可以使用厨房纸吸掉多余的油. 额外提一句. 厨房纸似乎在中国厨房里很少见 - 其实它很好用, 吸油吸水都很合适, 价格也不贵(我用的7块5买到两大卷), 一般超市纸制品的地方都有售.</p><h2 id="简单摆盘"><a href="#简单摆盘" class="headerlink" title="简单摆盘"></a>简单摆盘</h2><p>尝试了一下简单的摆盘布局. 立体堆积产生空间感, 加以新鲜薄荷叶撞色点缀.</p><p>目前正在研究这个方面的内容. 之后(小概率, 咕咕咕)会单独抽一篇来展开细节.</p><h2 id="百里香的添加"><a href="#百里香的添加" class="headerlink" title="百里香的添加"></a>百里香的添加</h2><p>为了验证百里香对于鸡肉烹调的重要性, 我这一次做了对比试验 - 其中有一块鸡肉在腌制的时候只放盐和黑胡椒. 事实证明这块鸡肉没有什么香气可言 - 主要是外面的脆壳带来的风味而吃不出鸡肉的风味.</p><h2 id="拍摄布光"><a href="#拍摄布光" class="headerlink" title="拍摄布光"></a>拍摄布光</h2><p>这一次既然有了<del>精致</del>走心的摆盘, 那么摄影就不能懈怠了. 由于桌面本身色调较暗的缘故, 我这一次选择使用较暗的环境光.(如上面两张图的对比, 上一次的背景光很亮)</p><p>主光源采用暖色的射灯, 垂直向下打在主体的右后方, 使得盘子上阴影不会过分夸张. 画面的右上角方向还有微弱的低色温环境光. 最后在后期处理的时候增强暗边, 可以使得注意力集中在画面的中心主体.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/fried-chicken-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>料理 | 基于食材的料理练习</title>
      <link>https://hisenz.com/post/ingredient-based-study/</link>
      <guid>https://hisenz.com/post/ingredient-based-study/</guid>
      <pubDate>Sun, 26 May 2019 12:47:19 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;料理 | 基于食材的料理练习&quot;&gt;&lt;p&gt;有的蔬菜吸油, 有的蔬菜不吸油. 这由食材本身的特性决定.&lt;/p&gt;&lt;p&gt;依我目前的浅见, 料理这门学问的核心是如何使手上的食材发挥出最大的潜力. 因此, 学习料理的第一步也就是熟悉各种食材的特性. 只有当厨师对于基本的食材特性了然于胸的时候, 卓越和创新才会成为可能.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="料理 | 基于食材的料理练习"><p>有的蔬菜吸油, 有的蔬菜不吸油. 这由食材本身的特性决定.</p><p>依我目前的浅见, 料理这门学问的核心是如何使手上的食材发挥出最大的潜力. 因此, 学习料理的第一步也就是熟悉各种食材的特性. 只有当厨师对于基本的食材特性了然于胸的时候, 卓越和创新才会成为可能.</p><a id="more"></a><p>过去做的每一份料理, 我都是当做习作作品来对待的, 所用的食材(肉类)也是西餐中常见的牛肉和鸡肉. 这是我对于肉类特性的探索. 我的关注点主要就集中在它们的特性上. 比方说, 鸡肉的缩水比牛肉要严重, 鸡皮可以带来特殊的口感(牛肉则没有这个concern), 等等.</p><h2 id="基于菜品分类的练习"><a href="#基于菜品分类的练习" class="headerlink" title="基于菜品分类的练习"></a>基于菜品分类的练习</h2><p>我翻看过一些西餐烹饪指南. 绝大多数的这些指南都是设计为简单的菜谱, 而最常见的安排内容的方法则是依照菜品的类型(这个名词我暂时没想到合适的中文, 先如此称呼), 如前菜, 汤, 主菜, 甜品等等. 如此一来, 想要做个汤的时候, 目录一翻便可找到合适的条目开始动手.</p><p>当然, 我无意攻击这样的练习方式. 每个人都会找到最合适自己的方式, 且基于菜品分类的练习确实可以短时间内速成料理技术. 但是, 我的哲学是无意速成. <strong>走捷径总是要付出代价的.</strong></p><h2 id="基于食材的练习"><a href="#基于食材的练习" class="headerlink" title="基于食材的练习"></a>基于食材的练习</h2><p>但是对着菜谱做菜, 这最多也只是学了个形似. 想到做到神似, 要知其所以然.</p><p>同一种食材, 可能使用在前菜里, 也同样出现在main course中. 这就是对于食材的特性在不同的维度上加以利用而做到的: 这背后是对于食材特性有深入了解; 如果我们只注重于菜品类型, 则很难在食材处理想象力上有所突破.</p><p>最后, 思考下面的这个列表或许对你有所启发:</p><ol><li>小番茄</li><li>土豆</li><li>柠檬</li><li>牛尾</li><li>青瓜</li><li>苏打水</li><li>鼠尾草</li></ol><p>它们各自都有什么特点? 如何处理(或搭配)可以利用这些特点来呈现出风味? 这些风味可以放到一顿饭中的哪些环节?</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/ingredient-based-study/#disqus_thread</comments>
    </item>
    
    <item>
      <title>后申请季的阅读</title>
      <link>https://hisenz.com/post/reading-after-application/</link>
      <guid>https://hisenz.com/post/reading-after-application/</guid>
      <pubDate>Mon, 13 May 2019 00:26:01 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;后申请季的阅读&quot;&gt;&lt;p&gt;后申请季从寒假开始算起, 到现在五月中旬, 已有三个月之久. 只有在这些赋闲的日子里, 我真正有了时间来实现去年念想的&lt;a href=&quot;/post/关于大量阅读的一些思考/&quot;&gt;大量阅读计划&lt;/a&gt;. 这里我回顾了三个月来主要阅读的作品, 简单记录一些想法.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="后申请季的阅读"><p>后申请季从寒假开始算起, 到现在五月中旬, 已有三个月之久. 只有在这些赋闲的日子里, 我真正有了时间来实现去年念想的<a href="/post/关于大量阅读的一些思考/">大量阅读计划</a>. 这里我回顾了三个月来主要阅读的作品, 简单记录一些想法.</p><a id="more"></a><p>这一次的读书范围主要包括一些在书单上躺了很久的西方名著, 一些我在申请时候没有空看但是心心念念了很久的”闲书”.</p><h2 id="悉达多"><a href="#悉达多" class="headerlink" title="悉达多"></a>悉达多</h2><p>这是一本浅显的哲学书. 不像其他的作品长篇大论, 这本书通过观察悉达多一生的故事, 让读者自己去领悟什么才是生命中最重要的东西.</p><p>这是我最近两年读的为数不多的虚构文学作品 - 在有一段时期我觉得虚构文学”没什么用” - 不过现在有了闲余时间, 读个几本也无所谓. 没想到在这之后我又继续阅读了许多虚构文学, 因为它的意义不像工具书所谓的”实用”, 它更多的是积淀, 为的是在往后的日子里, 一旦有了感悟, 自会联想到书中的情境.</p><h2 id="如何阅读一本小说"><a href="#如何阅读一本小说" class="headerlink" title="如何阅读一本小说"></a>如何阅读一本小说</h2><p>寒假作业书目, 其实算不上特别感兴趣, 只是因为之前有选修English Literature的经历, 所以翻起来也还算轻松 - 只是尚有许多提到的例子我没有读过, 体会不深. 我想等我阅读了足够数量的时候, 再回头看这本书, 还会有不少新的收获. 不过至少, 现在还是先专注的扩展阅读量吧.</p><p>其实这本书的原名是<em>How to Read Novels Like a Professor</em>. 我觉得翻译的时候去掉了<em>像个教授一样</em>是一处败笔 - 虽然此举增加了潜在读者的数量 - 因为这本书确实是从语言和历史的宏观角度来讨论小说这种文体, 而非大众所想的”若干条阅读建议”.</p><p>这本书其中一章讨论了小说开篇的学问, 也因此我开始阅读<em>Lolita</em>.</p><h2 id="洛丽塔"><a href="#洛丽塔" class="headerlink" title="洛丽塔"></a>洛丽塔</h2><p>入坑这本书缘于其开篇. 短短两段话, 变态的爱欲描绘到极致:</p><blockquote><p>Lolita, light of my life, fire of my loins. My sin, my soul. Lo-lee-ta: the tip of the tongue taking a trip of three steps down the palate to tap, at three, on the teeth. Lo. Lee .Ta.</p><p>She was Lo, plain Lo, in the morning, standing four feet ten in one sock. She was Lola in slacks. She was Dolly at school. She was Dolores on the dotted line. But in my arms she was always Lolita.</p></blockquote><p>在我看来Humbert真心的付出了爱, 而错的是时间. 时间(年龄差)令两人永远不可能走到一起 - 无论是否真爱. 这是时间的悲剧. 这是人们在面对时间之河时无力状的悲剧.</p><p>很棒的文学作品, 值得一读.</p><p><a href="https://www.zhihu.com/question/20834605/answer/21343310" rel="external nofollow noopener noreferrer" target="_blank">如何评价纳博科夫的《洛丽塔》 - 知乎</a></p><h2 id="我们"><a href="#我们" class="headerlink" title="我们"></a>我们</h2><p>反乌托邦三部曲中我唯一还没有看的一部, 大概也是在国内知名度较低的一本. 但是论创作时间来说, 它是<em>1984</em>的爷爷. 作为第一本比较出名的反乌托邦题材小说, 它影响了后来的<em>1984</em>和<em>美丽新世界</em> - 你总是可以在后两部作品中找到<em>我们</em>里的元素.</p><p>唯一的遗憾是, 我认为这本小说的后半部分过于仓促, 如果展开了写, 它将会是一本在文学上比肩<em>1984</em>的作品.</p><h2 id="房思琪的初恋乐园"><a href="#房思琪的初恋乐园" class="headerlink" title="房思琪的初恋乐园"></a>房思琪的初恋乐园</h2><p>读这本书是因为它和洛丽塔有一些联系. 况且这本书在书单上躺了很久, 所以朋友告诉我她正在阅读的时候, 也就上手了. 一个人深夜挑灯实在太孤独. 如果有两个人一起读书, 兴趣自然会浓厚.</p><p>这本书带有厚重的洛丽塔的影子. 两本书都涉及到文学这一主题 - 亨伯特是文学教授, 伊纹也受过良好的教育, 李老师也教语文. 文学在这其中扮演的角色, 我一时说不清. 大概是文学和人类的情感有异常紧密的联系, 因此作家们不约而同选择它作为设定的一大元素? 不同之处则在于故事构建在了当代的台湾社会上, 相关#MeToo运动, 确实和人们的生活更接近. 林警示世人性侵和家暴, 离人们并不遥远.</p><p>林在如何用语言调动感情这个问题上十分擅长, 有些话写的刺痛人心:</p><blockquote><p>他发现社会对性的禁忌感太方便了, 强暴一个女生, 全世界都觉得是她自己的错, 连她都觉得是自己的错. 罪恶感又会把她赶回他身边.</p><p>英文老师不会明白李国华第一次听说有女生自杀时那歌舞升平的感觉. 心里头清平调的海啸. 对一个男人最高的恭维就是为他自杀.</p></blockquote><p>另有林奕含的文集一部, 日后细细品鉴.</p><h2 id="人生最美是清欢"><a href="#人生最美是清欢" class="headerlink" title="人生最美是清欢"></a>人生最美是清欢</h2><p>俗世里, 人们借外物(理性, 物质等等)来控制自己的内心, 而禅宗 - 依我浅见 - 使用内心控制自己的内心. 清欢的实质是后者.</p><p>这本书我还没有看完. 这种文集大概就是闲时拿起来, 随性翻阅, 找寻清静之感, 不必一口气读完. 老林刚走不久, 所幸清欢相伴.</p><h2 id="罪与罚"><a href="#罪与罚" class="headerlink" title="罪与罚"></a>罪与罚</h2><p>这本书是<em>房思琪</em>里提到的. 尚未读完.</p><p>典型的俄国文学, 大部头, 细节繁多. 读了陀的作品, 我终于明白林奕含的语言大概是受到了陀思妥耶夫斯基的影响. 关于陀和他作品更多的讨论, 我大概会在日后单独写一篇 - 当我有足够积累的时候. (咕咕咕)</p><h2 id="富爸爸穷爸爸"><a href="#富爸爸穷爸爸" class="headerlink" title="富爸爸穷爸爸"></a>富爸爸穷爸爸</h2><p>一本知名的理财入门书, 在看了小土刀博客的理财文章后入手试读. 基本上的道理, 在改革开放40年后大家都懂了. 这本书最精辟的地方就是对于资产和负债的定义:</p><blockquote><p>资产就是往你口袋里赚钱的东西<br>负债就是从你口袋里掏钱的东西</p></blockquote><p>如此一来, 明辨资产和负债, 多购入资产来平衡现金流.</p><p>但是从文学角度来说这本书十分差劲, 值得看的主要也就是富爸爸给他上的第一课的内容, 其它皆为废话.</p><h2 id="工作前5年-决定你一生的财富"><a href="#工作前5年-决定你一生的财富" class="headerlink" title="工作前5年, 决定你一生的财富"></a>工作前5年, 决定你一生的财富</h2><p>继上一本书, 看了一本更加贴近国情的理财书. 我吹这本书的原因在于作者用自己五年的真实经历, 一步一步写出了如何开始理财和投资的过程. 虽然很多情况下过程并不能复制, 至少这本书让很多人看到了积累财富的希望.</p><p>看完这两本书, 结合2018年冬天炒币的血泪教训, 更加深刻的理解了”别人贪婪我恐惧, 别人恐惧我贪婪”的道理.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/reading-after-application/#disqus_thread</comments>
    </item>
    
    <item>
      <title>歌剧 | 从Carmen看歌剧的常见声部</title>
      <link>https://hisenz.com/post/voice-type/</link>
      <guid>https://hisenz.com/post/voice-type/</guid>
      <pubDate>Tue, 07 May 2019 03:10:34 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;歌剧 | 从Carmen看歌剧的常见声部&quot;&gt;&lt;p&gt;首演于1875, 歌剧卡门中的许多唱段至今仍然有着巨大的影响力. 在兴趣的驱使下, 我决定从比才的这部作品入手, 初探歌剧这种艺术形式. 这篇文章简要介绍了歌剧中常见的声音类型和与之对应的角色特征.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="歌剧 | 从Carmen看歌剧的常见声部"><p>首演于1875, 歌剧卡门中的许多唱段至今仍然有着巨大的影响力. 在兴趣的驱使下, 我决定从比才的这部作品入手, 初探歌剧这种艺术形式. 这篇文章简要介绍了歌剧中常见的声音类型和与之对应的角色特征.</p><a id="more"></a><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [{        name: 'Carmen, Act IV:No.26 Marche et Choeur: Les voici! Voici le quadrille! (Choeurs/Enfants)',        artist: 'Angela Gheorghiu,Roberto Alagna,Thomas Hampson,Michel Plasson',        url: 'https://img.vim-cn.com/b7/c20d7dfb08014f9d7ddc9d30f640b587651116.mp2',        cover: 'http://p1.music.126.net/PbUTTVtTVkILL1TrzVvTKw==/739971325515371.jpg?param=300x300'    }]});</script><h2 id="声部主要分类"><a href="#声部主要分类" class="headerlink" title="声部主要分类"></a>声部主要分类</h2><p>对于Opera, 声音是其中一个重要的元素. 为了保证戏剧的代入感, 歌剧在创作的时候会规定每一个角色的声音类型, 也就是中文语境下的声部. 观察下面这张卡门的角色表. 角色的声音类型定义十分明确 (节选自<a href="https://en.wikipedia.org/wiki/Carmen" rel="external nofollow noopener noreferrer" target="_blank">维基百科</a>)</p><table><thead><tr><th>Role</th><th><a href="https://en.wikipedia.org/wiki/Voice_type" rel="external nofollow noopener noreferrer" target="_blank">Voice type</a></th><th>Premiere cast, 3 March 1875 Conductor: <a href="https://en.wikipedia.org/wiki/Adolphe_Deloffre" rel="external nofollow noopener noreferrer" target="_blank">Adolphe Deloffre</a><a href="https://en.wikipedia.org/wiki/Carmen#cite_note-D112-14" rel="external nofollow noopener noreferrer" target="_blank">[13]</a></th></tr></thead><tbody><tr><td>Carmen, <em>A Gypsy Girl</em></td><td><a href="https://en.wikipedia.org/wiki/Mezzo-soprano" rel="external nofollow noopener noreferrer" target="_blank">mezzo-soprano</a></td><td><a href="https://en.wikipedia.org/wiki/C%C3%A9lestine_Galli-Mari%C3%A9" rel="external nofollow noopener noreferrer" target="_blank">Célestine Galli-Marié</a></td></tr><tr><td>Don José, <em>Corporal of Dragoons</em></td><td><a href="https://en.wikipedia.org/wiki/Tenor" rel="external nofollow noopener noreferrer" target="_blank">tenor</a></td><td><a href="https://en.wikipedia.org/wiki/Paul_Lh%C3%A9rie" rel="external nofollow noopener noreferrer" target="_blank">Paul Lhérie</a></td></tr><tr><td>Escamillo, <em>Toreador</em></td><td><a href="https://en.wikipedia.org/wiki/Bass-baritone" rel="external nofollow noopener noreferrer" target="_blank">bass-baritone</a></td><td><a href="https://en.wikipedia.org/wiki/Jacques_Bouhy" rel="external nofollow noopener noreferrer" target="_blank">Jacques Bouhy</a></td></tr><tr><td>Micaëla, <em>A Village Maiden</em></td><td><a href="https://en.wikipedia.org/wiki/Soprano" rel="external nofollow noopener noreferrer" target="_blank">soprano</a></td><td><a href="https://en.wikipedia.org/wiki/Marguerite_Chapuy" rel="external nofollow noopener noreferrer" target="_blank">Marguerite Chapuy</a></td></tr><tr><td>Zuniga, <em>Lieutenant of Dragoons</em></td><td><a href="https://en.wikipedia.org/wiki/Bass_(voice_type" rel="external nofollow noopener noreferrer" target="_blank">bass</a>)</td><td><a href="https://en.wikipedia.org/wiki/Eug%C3%A8ne_Dufriche" rel="external nofollow noopener noreferrer" target="_blank">Eugène Dufriche</a></td></tr><tr><td>Moralès, <em>Corporal of Dragoons</em></td><td><a href="https://en.wikipedia.org/wiki/Baritone" rel="external nofollow noopener noreferrer" target="_blank">baritone</a></td><td><a href="https://en.wikipedia.org/wiki/Edmond_Duvernoy" rel="external nofollow noopener noreferrer" target="_blank">Edmond Duvernoy</a></td></tr></tbody></table><p>其中Voice Type即为中文里的声部. 主要的声部分类如下:</p><ul><li>Male 男性<ul><li>countertenor 假声男高音</li><li>tenor 男高音</li><li>baritone 男中音</li><li>bass 男低音</li></ul></li><li>Female 女性<ul><li>soprano 女高音</li><li>mezzo-soprano 女次高音 / 女中音</li><li>contralto / alto 女低音</li></ul></li><li>Treble 童声</li></ul><p>每个大分类下还会有些许的子分类, 其实名目繁多, 这里便不做讨论了.</p><h2 id="声音类型和角色"><a href="#声音类型和角色" class="headerlink" title="声音类型和角色"></a>声音类型和角色</h2><p>国内戏剧, 生旦净丑每种行当都从声音, 服饰, 妆容等方面, 折射角色对应的性格和身份特征. 西方的歌剧也这方面也是类似的, 即不同的声音类型可以体现出不同的角色特点.</p><ul><li><p>In operatic drama, the soprano is almost always the heroine because she projects innocence and youth.</p><p>在歌剧中, 女英雄角色几乎都是女高音, 因为她们通常有纯洁和年轻的特质.</p></li><li><p>Many mezzo-sopranos sing the so-called “trouser” roles, portraying young boys or men. They can also be the villainesses or motherly types. One of the most well known roles for a dramatic mezzo is the fiery gypsy Carmen in the opera of the same name.</p><p>女中音常常扮演反串的角色, 例如年轻的男性. 女中音也可以扮演恶棍或是母亲的形象. Carmen在同名戏剧中就是一个著名的女中音角色.</p></li><li><p>This voice type (alto) is usually reserved for specialty roles like the earth goddess Erda in Richard Wagner’s Nordic fantasy-epic <em>The Ring of the Nibelung</em>. Since this is such a rare voice type, dramatic mezzos often sing roles in this range.</p><p>女低音通常被保留起来, 只在一些特定的角色上采用. 由于女低音音源十分罕见, 通常是有女中音来扮演.</p></li><li><p>For males, the tenor is generally considered to be the highest male voice in an opera, and is most often the hero or the love interest of the story.</p><p>男高音通常是英雄角色, 或是主角的恋爱对象. (在Carmen中Jose就是这样的一个角色)</p></li><li><p>A baritone is the most common type of male voice whose range lies midway between the high tenor voice and the low bass voice. In comedic operas, he is often the leader of the funny business, but he can also be the hero, who sacrifices himself for the tenor or soprano, or the villain.</p><p>男中音是最常见的男声; 在戏剧中担任搞笑任务, 但也可以作为一个英雄角色(为了男高音/女高音/恶霸牺牲).</p></li><li><p>A basso serio or basso profondo portrays characters who convey wisdom or nobility such as Sarastro in <em>The Magic Flute</em>.</p><p>男低音表现富有智慧或者身份尊贵的角色. (这似乎和洞穴人效应有关?)</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.operaphila.org/your-visit/attending-a-performance/opera-101/" rel="external nofollow noopener noreferrer" target="_blank">Opera 101 - Voice Type</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Carmen" rel="external nofollow noopener noreferrer" target="_blank">维基百科</a></p></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/voice-type/#disqus_thread</comments>
    </item>
    
    <item>
      <title>料理 | 完美鸡腿排指南</title>
      <link>https://hisenz.com/post/fried-chicken/</link>
      <guid>https://hisenz.com/post/fried-chicken/</guid>
      <pubDate>Sat, 04 May 2019 13:32:41 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;料理 | 完美鸡腿排指南&quot;&gt;&lt;p&gt;市售的鸡排大多是合成的鸡肉饼, 口感和来源均令人堪忧. 这篇教程教你如何从鸡腿开始做出一块完美鸡排.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="料理 | 完美鸡腿排指南"><p>市售的鸡排大多是合成的鸡肉饼, 口感和来源均令人堪忧. 这篇教程教你如何从鸡腿开始做出一块完美鸡排.</p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/05/04/EdXkh6.jpg" alt=""></p><h2 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h2><table><thead><tr><th style="text-align:center">食材</th><th style="text-align:center">数量</th><th style="text-align:center">市价/人民币</th></tr></thead><tbody><tr><td style="text-align:center">琵琶腿</td><td style="text-align:center">4个</td><td style="text-align:center">12.9</td></tr><tr><td style="text-align:center">鸡蛋</td><td style="text-align:center">2个</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">玉米淀粉</td><td style="text-align:center">适量 *</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">面粉</td><td style="text-align:center">适量 *</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">面包糠</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">海盐</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">现磨黑胡椒</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">橄榄油</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">大蒜(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">黄油(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">百里香(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">欧芹(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr></tbody></table><p>备注:</p><ol><li>玉米淀粉:面粉的比例在1:3左右</li><li>强烈建议添加百里香! 百里香和鸡肉的味道搭配令人十分愉悦.</li></ol><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><h3 id="剔骨"><a href="#剔骨" class="headerlink" title="剔骨"></a>剔骨</h3><p>想要剔骨的过程流畅的话, 在这一步操作前, <strong>请先磨刀</strong>. 不要问我怎么知道的.</p><p>剔骨的过程<del>很简单</del>需要一点耐心. 拿起鸡腿端详一圈. 从鸡腿贴近鸡身的那一面和那一端下刀. 沿着腿骨耐心划开鸡肉直至鸡爪的一端. 立起鸡腿, 手握在上的鸡爪一端, 用刀向下剔开鸡肉. 稍加修整可以得到一块完整的腿排.</p><p><del>好吧我知道这描述根本听不懂.</del> 可以参考<a href="https://www.bilibili.com/video/av33668013/" rel="external nofollow noopener noreferrer" target="_blank">这个视频</a>35秒处.</p><p>剔骨的过程多练习几遍, 就熟练了.</p><h3 id="腌制"><a href="#腌制" class="headerlink" title="腌制"></a>腌制</h3><p>在鸡皮上用牙签扎洞, 这样可以腌制得更入味, 也可以防止鸡皮油炸过程中过度收缩.</p><p>在鸡皮面仅抹上盐, 用力按揉. 翻面抹上盐, 现磨黑胡椒, 百里香的干叶. 百里香的气味和鸡肉十分搭配; 我怀疑吮指原味鸡的配方里也有这种的成分. 你可以在一些大超市里找到百里香 (我使用的这款麦德龙有售).</p><blockquote><p>题外话, 牛排和鼠尾草或者百里香的气味搭配起来都不错.</p></blockquote><p>适量抹上橄榄油可以让鸡肉变得更嫩. 等待15分钟左右鸡肉就会出水. 除去这些多余的水分, 下面开始最具技巧性的一步: 裹粉.</p><h3 id="裹粉"><a href="#裹粉" class="headerlink" title="裹粉"></a>裹粉</h3><p>裹粉的质量直接决定了最后成品的质量. 时刻记住 <strong>均匀</strong> 二字.</p><p>将玉米淀粉和面粉以<code>1:3</code>的比例混合拌匀. 放入已经开始腌制的鸡排, 均匀裹上一层. 再裹一层蛋液. 注意蛋液是全蛋而不仅是蛋清. 最后均匀粘上面包糠即可.</p><p>如果追求更厚的脆壳, 可以在第一次裹蛋液之后, 再裹一层混合粉和蛋液.</p><h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>时间的魔法是料理里的一个最重要也最难得的要诀. 很多时候, 优秀的料理不过是巧妙融入了时间这种元素. 我个人很喜欢一个叫做<code>肥丁手工坊</code>的料理频道, 她的许多作品, 比如<a href="https://www.bilibili.com/video/av46970609/" rel="external nofollow noopener noreferrer" target="_blank">酿酒</a>, 就需要耐心的观察与等待.</p><p>可惜快餐文化盛行的当代, 时间这种昂贵的元素, 早已在料理中难觅.</p><p>将裹好粉的腿排放入冰箱等待24小时左右, 使其腌制入味. 确保在油炸之前恢复到室温.</p><h3 id="油炸"><a href="#油炸" class="headerlink" title="油炸"></a>油炸</h3><p>由于面包糠的存在, 我们需要 <strong>低温油炸</strong> , 防止外壳焦化并确保腿排熟透.</p><p><strong>不要使用黄油油炸</strong>, 因为黄油在高温下很容易焦化. 黄油在鸡排出锅后放在脆壳上融化, 用以提升香气.</p><p>下<strong>宽油</strong>(橄榄油), 如果喜欢蒜香的话可以下带皮的蒜瓣 (不然容易焦). 把一根木质的筷子戳入油里, 开始冒泡意味着油温到了合适的水平. 将带皮的一面向下放置. 保持低温油炸. 保持低温油炸. 保持低温油炸.</p><p>判断鸡肉熟成的方法如下: 当鸡肉成熟以后会开始析出汤汁 (直到完全变柴), 而水份碰到热油会发生溅射. 当反应逐渐变弱的时候, 就说明鸡肉开始变干了, 已经熟成.</p><p>沥干控油. 讲究的话可以用厨房纸吸去多余的油. 静置一段时间即可装盘, 撒上欧芹叶装饰.</p><p><img src="https://s2.ax1x.com/2019/05/04/EdXE9K.jpg" alt=""></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如同<a href="/post/Sous-Vide/#%E8%88%92%E8%82%A5%E9%B8%A1%E8%83%B8%E8%82%89">舒肥鸡胸肉</a>一样, 可以搭配土豆泥和白葡萄酒. 可乐也是个不错的选择.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/fried-chicken/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mac双系统之删除Windows系统</title>
      <link>https://hisenz.com/post/remove-win-on-mac/</link>
      <guid>https://hisenz.com/post/remove-win-on-mac/</guid>
      <pubDate>Sat, 27 Apr 2019 06:08:16 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客&quot;&gt;&lt;p&gt;很多同学在Mac上通过Bootcamp安装了双系统之后, 由于种种原因, 想要卸载Windows操作系统并释放磁盘空间. 这一篇教程教你如何卸载Windows, 部分内容编译自StackOverflow的&lt;a href=&quot;https://apple.stackexchange.com/a/344481&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;这个回答&lt;/a&gt;.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客"><p>很多同学在Mac上通过Bootcamp安装了双系统之后, 由于种种原因, 想要卸载Windows操作系统并释放磁盘空间. 这一篇教程教你如何卸载Windows, 部分内容编译自StackOverflow的<a href="https://apple.stackexchange.com/a/344481" rel="external nofollow noopener noreferrer" target="_blank">这个回答</a>.</p><a id="more"></a><h2 id="Bootcamp-卸载"><a href="#Bootcamp-卸载" class="headerlink" title="Bootcamp 卸载"></a>Bootcamp 卸载</h2><p>由于Bootcamp分区的特殊性, 不可以直接通过格式化来释放空间.</p><p>在软件列表里打开Bootcamp, 按照向导提示完成. 如果出现了以下错误:</p><blockquote><p>The startup disk cannot be partitioned or restored to a single partition.</p></blockquote><p>请继续阅读以下部分.</p><h2 id="命令行卸载"><a href="#命令行卸载" class="headerlink" title="命令行卸载"></a>命令行卸载</h2><ol start="0"><li><p>打开磁盘实用程序(Disk Utility), 在左侧查看分区. 右侧的详细信息里中如果写有NTFS则表明这是个Windows分区. 记下这个分区的名字(左侧显示的名字).</p></li><li><p>在软件列表里搜索”terminal”, 打开终端(默认白底黑字的窗口).</p></li><li><p>格式化Windows分区:</p><blockquote><p>这一步操作不慎可能导致数据丢失.</p></blockquote><p>依次输入命令(大小写敏感, 每行末尾有回车):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil eraseVolume free none disk0s4</span><br><span class="line">sudo diskutil eraseVolume free none disk0s3</span><br></pre></td></tr></table></figure><p>在输入第一行回车后会询问登录密码. 密码输入的时候没有回显. 输入完成后回车确认.<br>成功的输出看上去像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Started erase on disk0s4 BOOTCAMP</span><br><span class="line">Unmounting disk</span><br><span class="line">Finished erase on disk0</span><br></pre></td></tr></table></figure><p>通常来说只有<code>disk0s3`</code>disk0s4<code>被占用. 少数机器</code>disk0s5`也被占用. 这种情况需要灵活应对, 把上面命令里的分区名改为需要擦除的分区名即可.</p></li><li><p>调整苹果分区大小<br>继续输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil apfs resizeContainer disk0s2 0</span><br></pre></td></tr></table></figure><p>成功的输出看上去像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...(省略)</span><br><span class="line">Growing APFS data structures</span><br><span class="line">Finished APFS operation</span><br></pre></td></tr></table></figure></li><li><p>清理启动文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil mount disk0s1</span><br><span class="line"><span class="built_in">cd</span> /Volumes/EFI/EFI</span><br><span class="line">rm -r Boot</span><br><span class="line">rm -r Microsoft</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">diskutil unmount disk0s1</span><br></pre></td></tr></table></figure><p>rm这一步如果出现Error, 无需采取措施. 这个错误说明安装时候采用的是legacy方式.</p></li><li><p>所有工作已完成. 再次打开Disk Utility来确认刚刚的工作成果.</p></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/remove-win-on-mac/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | 身份证号校验</title>
      <link>https://hisenz.com/post/id-card/</link>
      <guid>https://hisenz.com/post/id-card/</guid>
      <pubDate>Tue, 16 Apr 2019 04:47:05 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客&quot;&gt;&lt;blockquote&gt;&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;2013年开始中国全面使用第二代居民身份证. 目前我国公民身份证号码由18位数字组成: 前6位为&lt;code&gt;地址码&lt;/code&gt;, 第7至14位为&lt;code&gt;出生日期码&lt;/code&gt;, 第15至17位为&lt;code&gt;顺序码&lt;/code&gt;, 第18位为&lt;code&gt;校验码&lt;/code&gt;. 其中第18位&lt;code&gt;校验码&lt;/code&gt;用于快速检测身份证号是否合法(以防止输入错误等情况).&lt;/p&gt;&lt;p&gt;校验过程如下:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;将身份证号逐位乘以对应的&lt;strong&gt;权重&lt;/strong&gt;, 其中&lt;code&gt;X&lt;/code&gt;表示数字&lt;code&gt;10&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;对上一步的结果求和&lt;/li&gt;&lt;li&gt;将校验和对&lt;code&gt;11&lt;/code&gt;取模 &lt;code&gt;mod 11&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果结果为&lt;code&gt;1&lt;/code&gt;, 则该身份证号合法.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上述权重规定于&lt;strong&gt;中华人民共和国国家标准GB11643-1999&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;在这个挑战里, 你需要编写一个程序来检验输入的身份证号是否合法.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>2013年开始中国全面使用第二代居民身份证. 目前我国公民身份证号码由18位数字组成: 前6位为<code>地址码</code>, 第7至14位为<code>出生日期码</code>, 第15至17位为<code>顺序码</code>, 第18位为<code>校验码</code>. 其中第18位<code>校验码</code>用于快速检测身份证号是否合法(以防止输入错误等情况).</p><p>校验过程如下:</p><ol><li>将身份证号逐位乘以对应的<strong>权重</strong>, 其中<code>X</code>表示数字<code>10</code>.</li><li>对上一步的结果求和</li><li>将校验和对<code>11</code>取模 <code>mod 11</code></li><li>如果结果为<code>1</code>, 则该身份证号合法.</li></ol><p>上述权重规定于<strong>中华人民共和国国家标准GB11643-1999</strong>.</p><p>在这个挑战里, 你需要编写一个程序来检验输入的身份证号是否合法.</p><a id="more"></a><p>这里以身份证号<code>11010519491231002X</code>为例, 演示上述过程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序号 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 </span><br><span class="line">权重 07 09 10 05 08 04 02 01 06 03 07 09 10 05 08 04 02 01 </span><br><span class="line">号码 01 01 00 01 00 05 01 09 04 09 01 02 03 01 00 00 02 10</span><br></pre></td></tr></table></figure><ol><li><p>乘以权重并求和<br>$$<br>7\cdot1+9\cdot1+ …+1\cdot10 = 177<br>$$</p></li><li><p>对<code>11</code>取模<br>$$<br>177 \mod11 = 1<br>$$</p></li></ol><p>因为结果为<code>1</code>, 该身份证号有效.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>从标准输入接收一个身份证号码. 如果该输入是有效号码则输出<code>VALID</code>字样. 否则输出<code>INVALID</code>.</p><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11010519491231002X</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VALID</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">330301194912310021</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INVALID</span><br></pre></td></tr></table></figure><h2 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a>完成度</h2><p>本挑战的完成度分为两个等级</p><ol><li>可以求出校验和</li><li>可以输出样例中的期望结果</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>强化数据类型和类型转换</li><li>强化列表与字符串的操作</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%212317&authkey=ABPeKy9KkwNQM4k" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基文库:<ul><li><code>GB_11643-1999.pdf</code></li></ul></li></ol><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol><li>字符串对象可以视作列表来操作</li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/id-card/#disqus_thread</comments>
    </item>
    
    <item>
      <title>面对无限</title>
      <link>https://hisenz.com/post/The-Graduate/</link>
      <guid>https://hisenz.com/post/The-Graduate/</guid>
      <pubDate>Thu, 11 Apr 2019 05:03:04 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客&quot;&gt;&lt;blockquote&gt;&lt;p&gt;在无穷中, 我们孤独行舟.&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客"><blockquote><p>在无穷中, 我们孤独行舟.</p></blockquote><a id="more"></a><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [{        name: 'The Sound Of Silence',        artist: 'Simon & Garfunkel',        url:'https://img.vim-cn.com/a2/8ce546d286fa7b3e0f74c1e245036ded9e1278.mp2',        cover: 'http://p1.music.126.net/CyphdMz6SkHmpQbacGjGJw==/6647647302210685.jpg?param=130y130'    }]});</script><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>当我看到最近释出的首张黑洞照片, 瞬间一阵恐惧袭来. 尽管存在于同一个宇宙, 这于五千四百万光年外的存在, 是我有生之年永远也无法触及的地方. 倒不如承认它根本就在另外一个与我毫不相干的世界里.</p><p>无穷的距离意味着无穷的不确定性. 当距离遥远, 以至于相对于人类的短暂一生来说是无限之时, 我们还有足够的勇气继续前进吗? 我们还会驶着一叶小舟, 以孤独为伴, 向无穷的虚空空中进发吗?</p><p><img src="https://img.vim-cn.com/24/1b30bba1b7b699a06d7a2f9b96902cd84c1aca.jpg" alt="图片来源 https://live.staticflickr.com/7852/32636958507_973007bd5b_b.jpg"></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>高中的三年快要结束了. 原本以为申请季之后剩下的只有轻松 - 这话放到现在看也确实没错 - 只是伴随着轻松而来的是迷茫. 人生的第一次, 我出现了大片的空白时间. 从读了小学开始便不再有过这样的体验: 每一天总是安排的满满当当, 每一周里也难得有半天的闲暇. 十二年来, 我重复着我认为理所应当的日程. 铁打的安排. 流水的年岁. 年年如此.</p><p>直到这段路走到尽头.</p><p>一如电影毕业生, 危机感向我不断的压来. 我面前是一片空白, 一尘不染; 是一片无限的可能. 在将来的两三个月里是这样, 在未来的四年里也是这样. 前路有无限种可能性, 我尽可以在这两三个月的时间徘徊在这个人生的岔路口,而我最终只能选择其中一条走下去.</p><blockquote><p>I shall be telling this with a sigh<br>Somewhere ages and ages hence:<br>Two roads diverged in a wood, and I–<br>I took the one less traveled by,<br>And that has made all the difference.</p><p>– Robert Frost, <i>The Road Not Taken</i></p></blockquote><p>权衡着机会成本与试错的沉没成本, 我反复问我自己, 我到底该做出怎么样的决定.</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>不过严格来说, 初三时候的我也曾走过一次十字路口, 当时的我大概多少也有这样的担忧. 虽说两三个月也没有折腾出什么成绩, 那却是我这辈子前十八年里心态最佳的时候.</p><p>刚刚上高中那会, 觉得世上本不存在什么不可能的事. 所谓障碍和限制都是人们的臆想或是人为的设置, 仿佛没有物理限制的事情, 我都可以通过直接或者间接的方式达成. 现在三年走下来, 碰壁不少, 也终于觉察到这想法里的些许激进. 当然, 世上仍然没有什么不可能的事, 并且有着”条条大路通罗马”之类的真理在背后撑腰, 然而如果没有合适的资源和天成的机遇, 步骤或许繁杂到难以操作, 其实这么点道理, 老话早已归结了: “做事在人, 成事在天.”</p><p>不过还是要感谢当时的我抱有那样的想法. 因为曾经站在愚昧巅峰, 才有着后来的自信崩塌和绝望低谷. 如果不是如此, 大概这三年来, 我无从获取前进动力.</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>那一段最猖狂的日子里, 我什么都敢叫板: 我不计后果地践行着我认为正确的选择. 我敢于表达自己的价值观. 我伸张正义. 多亏这三年我校领导和家人的”大力栽培”, 我现在做事前都会算计一番, 怎么对自己有利怎么来. 一夜之间, 我从一个哲学家被迫沦为政客.</p><p>高中给我带来最大的收获便是让我见识了黑暗到底可以有多黑暗, 让我初步窥见了”人-脸-钱-权”之间的关系. 世人忘记了”正直”两字怎么写固然很可惜. 然而最不可原谅的是我也忘了这两个字怎么写. 有时看到身边的人, 隔阂感莫名而生, 这令我很不安. 三年前的我看到现在的自己, 会唾弃成什么样?</p><p>活成了自己唾弃的模样, 最惨不过如此.</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>过去的三年也绝非暗无天日, 因为身边有着一群有趣的人. 人是社会动物, 不断受到社会环境的影响. 当身边有更优秀的存在时, 会不由自主的学习对方的优点. (能不能习得则是另一回事).</p><p>他们中的许多人是精神榜样. 和有些人交往的时候让我重新思考一些司空见惯的事物. 有些鼓励我重新开始阅读. 有些人教我为人处世的准则. 这三年间的高光时刻, 都离不开他们. 很幸运碰到了你们.</p><h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2><p>现在诉说的这些种种过往, 都是当时的未知. 时隔三年, 现在我又走到了一个更加错综复杂的岔路口.</p><p>兴奋显然掩盖不住对于无限未来的担忧. 我知道我变了. 也或许没有. 可是纵使再有多的不确定性, 未来在到来的那一刻也会告诉我确切的命运安排.</p><p>在畏惧无穷的时候, 低头看看脚下或许是个不错的主意.</p><p>我将独自穿行于无穷.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/The-Graduate/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | Brainfuck语言解释器</title>
      <link>https://hisenz.com/post/bf-challenge/</link>
      <guid>https://hisenz.com/post/bf-challenge/</guid>
      <pubDate>Mon, 01 Apr 2019 11:53:42 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;挑战 | Brainfuck语言解释器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;++++++++++ [&amp;gt;+++++++ &amp;gt;++++++++++ &amp;gt;+++&amp;gt;+&amp;lt;&amp;lt;&amp;lt;&amp;lt;-]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;++.&amp;gt;+.+++++++ ..+++.&amp;gt;++.&amp;lt;&amp;lt;+++++++++++++++ .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;.+++.------ .-------- .&amp;gt;+.&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;BF的工作原理模拟了一台简单的图灵机&lt;code&gt;Turing Machine&lt;/code&gt;. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务.&lt;/p&gt;&lt;p&gt;虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论&lt;code&gt;Computation Theory&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;在这个挑战里, 你需要编写一个解释器来运行BF语言.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="挑战 | Brainfuck语言解释器"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p>BF的工作原理模拟了一台简单的图灵机<code>Turing Machine</code>. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务.</p><p>虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论<code>Computation Theory</code>.</p><p>在这个挑战里, 你需要编写一个解释器来运行BF语言.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++</span><br><span class="line">&gt;+&gt;&gt;&gt;&gt;++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">&gt;++++++++++++++++++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;[&gt;[&gt;&gt;&gt;&gt;&gt;&gt;+&gt;</span><br><span class="line">+&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;[&gt;++++++++++[-</span><br><span class="line">&lt;-[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]&gt;[&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;</span><br><span class="line">-]&gt;&gt;[-]]&lt;&lt;]&gt;&gt;&gt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]</span><br><span class="line">&gt;[&lt;&lt;+&gt;&gt;[-]]&lt;&lt;&lt;&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;&gt;[+++++++++++++++++++++++++</span><br><span class="line">+++++++++++++++++++++++.[-]]++++++++++&lt;[-&gt;-&lt;]&gt;++++</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;+&gt;+&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;-]&lt;-[&gt;&gt;.&gt;.&lt;&lt;&lt;</span><br><span class="line">[-]]&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]&lt;&lt;[&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</span><br></pre></td></tr></table></figure><h2 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a>完成度</h2><p>本挑战的完成度分为三个等级</p><ol><li>可以解析<code>+</code>,<code>-</code>,<code>&lt;</code>,<code>&gt;</code>四种操作</li><li>可以解析<code>.</code>,<code>,</code>两种操作</li><li>可以解析循环</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>学习图灵计算模型</li><li>学习ASCII编码</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li><li>理解编程语言的本质</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%211344&authkey=APVSI6GDKYRggf0" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基百科:<ul><li><code>brainfuck.pdf</code></li><li><code>turing_machine.pdf</code></li><li><code>ascii.pdf</code></li></ul></li><li>视频 &amp; 英语字幕:<ul><li><code>How Brainfuck Work.mp4</code></li><li><code>How Brainfuck Works.ass</code></li></ul></li><li>在线 Brainfuck Visualizer<ul><li><a href="https://fatiherikli.github.io/brainfuck-visualizer/" rel="external nofollow noopener noreferrer" target="_blank">https://fatiherikli.github.io/brainfuck-visualizer/</a></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/bf-challenge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C语言 | 从内存视角看函数和指针的本质</title>
      <link>https://hisenz.com/post/functions-in-C-and-assambly/</link>
      <guid>https://hisenz.com/post/functions-in-C-and-assambly/</guid>
      <pubDate>Mon, 04 Mar 2019 13:26:29 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;descrription&quot; itemprop=&quot;descrription&quot; content=&quot;C语言 | 从内存视角看函数和指针的本质&quot;&gt;&lt;p&gt;近期在尝试编写一个&lt;code&gt;Simpson&amp;#39;s Rule&lt;/code&gt;近似数值积分的例子, 忽然想到可以把被积函数作为一个参数传入, 使这个积分函数更具有通用性. 这个例子我们会在文末作为实际应用来阐述. 在开始之前, 我们先要讨论一下C语言里的函数到底和函数调用到底是什么.&lt;/p&gt;&lt;p&gt;这篇文章篇幅较长, 且涉及较多示例和证明代码, 建议在桌面设备上阅读. 对于证明代码, 请务必亲自动手编译, 只有真正动手敲过的代码才算有深入理解.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="descrription" itemprop="descrription" content="C语言 | 从内存视角看函数和指针的本质"><p>近期在尝试编写一个<code>Simpson&#39;s Rule</code>近似数值积分的例子, 忽然想到可以把被积函数作为一个参数传入, 使这个积分函数更具有通用性. 这个例子我们会在文末作为实际应用来阐述. 在开始之前, 我们先要讨论一下C语言里的函数到底和函数调用到底是什么.</p><p>这篇文章篇幅较长, 且涉及较多示例和证明代码, 建议在桌面设备上阅读. 对于证明代码, 请务必亲自动手编译, 只有真正动手敲过的代码才算有深入理解.</p><a id="more"></a><p>文章的第一节我们从指令和数据的区别出发, 窥见函数与调用的本质. 第二节分析函数在内存里的位置, 理解程序运行时的内存分布. 第三节在前两板块的基础上描述函数的调用和参数传递之细节. 第四节讨论值传参和指针传参, 包括如何将函数作为参数以传递. 第五节是围绕辛普森法积分例程讲解, 综合前文内容作为函数指针的应用演示.</p><h2 id="函数与调用的本质"><a href="#函数与调用的本质" class="headerlink" title="函数与调用的本质"></a>函数与调用的本质</h2><h3 id="数据-vs-指令"><a href="#数据-vs-指令" class="headerlink" title="数据 vs. 指令"></a>数据 vs. 指令</h3><blockquote><p>函数就是一段计算机指令的序列</p></blockquote><p><img src="https://img.vim-cn.com/ab/0ae6b54603d721196f056c3d377a11ca7028e0.png" alt=""></p><p>在<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture" rel="external nofollow noopener noreferrer" target="_blank">冯诺依曼架构</a>中, 数据和指令存放在一起. 因为这种架构只需要一套存储器, 在计算机工业早期实现成本较低, 也演化成了今天的主流方案.</p><p>程序是数据和指令的集合. 程序里预先定义好的常量是数据. 程序要求预留的空间(变量)也是数据. 注意计算机并不能理解数据.</p><p>指令定义了计算机的行为, 指示计算机如何处理数据. 那么与数据同样是比特的指令有什么特殊性? 那就是指令可以控制计算机来达到我们预期的操作; 只有一些特殊的控制字(指令)可以达到这个目的, 而控制字<code>Command Word</code>和底层的电路设计息息相关.</p><p>其次, 在正常情况下, 计算机的控制权不会转交到数据上. 这是因为数据本身并不能控制计算机; 计算机无法理解这些未知的控制字, 就会触发异常.</p><p>由于冯诺依曼架构下数据和指令存放在一起, 如果因为某种”巧合”, 数据恰好也是对计算机而言有意义的控制字, 那么计算机就会认为这些数据是指令. 利用精心构造的数据来改变计算机的行为, 是一种常见的攻击手法, 如<a href="https://en.wikipedia.org/wiki/Buffer_overflow" rel="external nofollow noopener noreferrer" target="_blank">缓冲区溢出</a>的利用. 这个概念下文我们还会简略提到.</p><p>读到这里我们总结一下上文: 计算机可以执行(理解)的是指令.</p><p><strong>函数就是一段计算机指令的序列</strong>, 这段代码的第一条指令的地址也就是函数的入口地址. 要执行一段指令, 只需要让计算机把控制权转交给这个函数.</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><blockquote><p>调用是把rip指向函数起始地址的行为</p></blockquote><p>我们看一个简单的C语言例子<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">abs</span>(<span class="number">-1024</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译&amp;反汇编<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --no-builtin 排除掉了内建的函数</span></span><br><span class="line">gcc abs.c -o abs --no-builtin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 反汇编</span></span><br><span class="line">objdump -d abs</span><br></pre></td></tr></table></figure><p></p><p>以下摘取相关反汇编片段<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">000000000000061a &lt;abs&gt;:</span><br><span class="line"> 61a:push   %rbp</span><br><span class="line"> 61b:mov    %rsp,%rbp</span><br><span class="line"> 61e:mov    %edi,-0x4(%rbp)  ; pass parameter</span><br><span class="line"> 621:mov    -0x4(%rbp),%eax  ; save it in eax</span><br><span class="line"> 624:cltd                    ; sign-extend</span><br><span class="line"> 625:mov    %edx,%eax        ;</span><br><span class="line"> 627:xor    -0x4(%rbp),%eax  ; tricks</span><br><span class="line"> 62a:sub    %edx,%eax        ; see my previous post</span><br><span class="line"> 62c:pop    %rbp</span><br><span class="line"> 62d:retq   </span><br><span class="line"></span><br><span class="line">000000000000062e &lt;main&gt;:</span><br><span class="line"> 62e:push   %rbp</span><br><span class="line"> 62f:mov    %rsp,%rbp</span><br><span class="line"> 632:mov    $0xfffffc00,%edi ; param -1024</span><br><span class="line"> 637:callq  61a &lt;abs&gt;        ; function call</span><br><span class="line"> 63c:mov    $0x0,%eax        ; return 0</span><br><span class="line"> 641:pop    %rbp             ;</span><br><span class="line"> 642:retq                    ;</span><br></pre></td></tr></table></figure><p></p><p>注: 汇编代码里关于<code>mov</code>与<code>xor</code>的注解请前往我的<a href="/post/利用越界和溢出-C语言/">这篇博文</a>, 此处不深究.</p><p>这里的<code>rip</code>是<code>Instruction Pointer</code>指令指针寄存器, 一个位于CPU的寄存器, 存储着下一条指令的内存地址.</p><p>从高级语言的层面来看, 执行函数的行为叫做<code>call</code>调用. <strong>调用是把rip指向函数起始地址的行为</strong>. 函数起始地址即函数第一条指令所在的地址. 控制权的所在, 就是<code>rip</code>指向的地址.</p><p>默认情况下, rip会顺次指向下一条指令的内存地址. 如X64下<code>pop</code>和<code>push</code>带上参数<code>%rbp</code>以后长度刚好是1字节. 这种情况下执行完一条指令以后, <code>rip</code>直接加一即可. 在一些架构上每条指令长度不等, <code>rip</code>会根据该指令的长度自动递增. 有一些指令, 如<code>call</code>调用指令和<code>jmp</code>强制跳转指令会修改<code>rip</code>寄存器的值, 以实现循环和条件语句. 前者专门用于函数的调用.</p><p>下面我们单步追踪. 假设将要执行的指令位于<code>0x00000637</code>.</p><h4 id="0x00000637"><a href="#0x00000637" class="headerlink" title="0x00000637"></a>0x00000637</h4><p>例子里我们在<code>main</code>中调用了函数<code>abs</code>. 此时rip指向<code>0x00000637</code>.</p><p>反汇编代码中得知<code>abs</code>函数入口位于内存地址<code>0x0000061a</code>. 因此调用<code>abs</code>的汇编代码为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    0x0000061a</span><br></pre></td></tr></table></figure><p>使用<code>jmp</code>的等价版本.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push    %rip</span><br><span class="line">jmp     0x0000061a</span><br></pre></td></tr></table></figure><p>指令<code>call</code>把当前<code>rip</code>寄存器的值(也就是<code>call</code>的下一条指令地址)先保存在栈上, 然后修改值为跳转的目标地址<code>0x0000061a</code>. 这样计算机的控制权就转跳到了这个地址上的指令, 函数开始执行. <code>jmp</code>指令则不会保存上下文而仅仅直接跳转.</p><p>执行完成后, <code>rip</code>值为<code>0x0000061a</code>, 栈上保存的值为<code>0x0000063c</code>. 换言之, 下一条要被执行的指令是<code>abs</code>里的第一条指令<code>push</code>.</p><p><code>abs</code>函数中间过程我们步过, 直到<code>abs</code>的最后一条指令<code>ret</code>. 此时<code>rip</code>指向<code>0x0000062d</code>的<code>ret</code>指令.</p><h4 id="0x0000062d"><a href="#0x0000062d" class="headerlink" title="0x0000062d"></a>0x0000062d</h4><p>函数调用结束的最后需要使用<code>ret</code>指令来恢复原来的地址. <code>ret</code>指令与<code>call</code>指令配对使用. <code>ret</code>的操作过程刚好相反, 从栈上弹出原先保存的地址并写回<code>rip</code>寄存器. 函数调用至此结束.</p><p>栈上保存的地址为<code>0x0000063c</code>, 弹出到<code>rip</code>.</p><p>此时rip指向<code>0x0000063c</code>, 是main函数里<code>call</code>的下一条指令.</p><h2 id="函数的内存位置"><a href="#函数的内存位置" class="headerlink" title="函数的内存位置"></a>函数的内存位置</h2><p>这一节我们一起动手实操, 探究一下运行时堆栈和函数指令存放的位置. 我们需要写一段程序, 这段程序会在不同的位置创建变量并打印出它们的地址.</p><p>注意, 这里的stack和heap都不是准确的地址. 这是因为<a href="https://blog.csdn.net/a511244213/article/details/44994755" rel="external nofollow noopener noreferrer" target="_blank">main函数并非是真正的程序入口</a>; 在这之前还有一些编译器和链接器附上的初始化或是安全保护(如栈保护)代码. 但是这些地址的相对位置足够说明一些事实了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> initialized_var = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> uninitialized_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> local_var_1;</span><br><span class="line">    <span class="keyword">char</span> local_var_2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack 1\t\t%p\n"</span>, &amp;local_var_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack 2\t\t%p\n"</span>, &amp;local_var_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// argc, argv</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv\t\t%p\n"</span>, argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argc\t\t%p\n"</span>, &amp;argc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack address </span></span><br><span class="line">    show_stack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap address</span></span><br><span class="line">    <span class="keyword">char</span> *heap_addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"heap\t\t%p\n"</span>,heap_addr);</span><br><span class="line">    <span class="built_in">free</span>(heap_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uninitialized varibles</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> uninitialized;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uninitialized\t%p\n"</span>, &amp;uninitialized_var);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialized varibles</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> initialized;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"initialized\t%p\n"</span>, &amp;initialized_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// text segment</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"text\t\t%p\n"</span>, show_stack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">argv0x7ffc1d303928</span><br><span class="line">argc0x7ffc1d30382c</span><br><span class="line">stack 10x7ffc1d30380f</span><br><span class="line">stack 20x7ffc1d30380e</span><br><span class="line">heap0x563138330670</span><br><span class="line">uninitialized0x563138326042</span><br><span class="line">initialized0x563138326041</span><br><span class="line">text0x5631381256da</span><br></pre></td></tr></table></figure><p></p><p>对照我们的输出和下面的图示, 逐条分析输出. 分析从高地址向低地址进行.<br><img src="https://img.vim-cn.com/ae/1b6f9da809fafa99be9907cbaf2eab4fc027cc.jpg" alt=""></p><ol><li><p>argc &amp; argv</p><p>这两个变量是主函数的两个参数. argc 是参数个数, argv是参数列表指针, 其中argv[0]指向运行的程序名字符串. 这两个变量是<a href="https://en.wikipedia.org/wiki/Exec_(system_call" rel="external nofollow noopener noreferrer" target="_blank">exec</a>)赋予的. 在图上, 它们位于最高的地址位置.</p></li><li><p>stack 1与stack 2</p><p>栈是由计算机自动分配和释放的, 这套规则由编译器决定. 具体的机器级表示请阅读下一节.</p><p>这里为了演示栈的地址增长方向, 我们在show_stack的栈帧上分配了两个局部变量. 还记得局部变量分配在stack栈上吗? 先分配的变量位于高地址, 后分配的位于低地址.</p><p>栈区的空间相比于堆区来说要小很多.</p></li><li><p>heap</p><p>用malloc手动分配的内存的空间位于堆上. 堆是从低地址向高地址增长的. 这里并没有演示出来, 有兴趣的读者可以动手试一试, 方法和上面观察stack增长方向一致.</p><p>图中可以看到, stack和heap是动态区域. 堆起始地址以下的内存是静态空间, 是<a href="https://en.wikipedia.org/wiki/Exec_(system_call" rel="external nofollow noopener noreferrer" target="_blank">exec</a>)根据<a href="https://baike.baidu.com/item/ELF/7120560" rel="external nofollow noopener noreferrer" target="_blank">ELF</a>从外部存储器加载到内存里的一个映像. 关于exec和ELF的一些细节, 以后会再写一篇文章详细讲述.</p></li><li><p>uninitialized</p><p>这里存放着没有初始化的变量. 也称为bss段. 由exec初始化为零.</p></li><li><p>initialized</p><p>这里存放代码里初始化的变量.</p><p>注意, 这里两个变量都是全局变量, declare在所有函数之外, 使用<code>extern</code>引入. 为什么不直接在主函数里声明呢? 其实如果仔细阅读了stack这一段的话, 你会意识到函数内声明的变量都是分配在栈上的. main函数也是函数, 如果在函数内定义变量, 则会默认在栈上分配空间.</p></li><li><p>text</p><p>文本段, 存放程序代码和字符串常量. 我们打印了函数show_stack的地址(等同于其入口地址).</p><p>如果稍加思索, 就会发现正常情况下rip指向的范围只会在text段里.</p></li></ol><p>综上所述, 函数的指令存放在text段, 运行时函数会操作栈区和堆区. 现在再回头看看第一节里指令和数据的区别, 是否更加的清晰了呢?</p><h2 id="调用规范和参数传递"><a href="#调用规范和参数传递" class="headerlink" title="调用规范和参数传递"></a>调用规范和参数传递</h2><p>在函数调用的本质里我们详细阐述了函数调用在机器层面的表示. 但是细心的读者会发现我们并没有讨论到函数参数的传递. 这里涉及到了<code>callee</code>被调用函数和<code>caller</code>调用者之间的配合.</p><p>C风格的函数传参会在函数调用前, 首先把参数从右到左(从参数列表里的最后一个开始)入栈. 在函数内使用到参数的时候则以<code>%rbp + offset</code>来表示这个特定的参数. 注意这里是<code>+</code>号, 因为 <strong>栈的地址是从高向低增长的</strong>.</p><p>X86默认所有参数从栈上传递, 而X64则把最后四个大小合适的参数<a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2017#parameter-passing" rel="external nofollow noopener noreferrer" target="_blank">通过寄存器传递</a>, 其余的参数同样通过栈传递. 这是因为X64多了好几个寄存器, 且通过寄存器传参的速度远快于内存. 当然这也就对参数的类型做出了限制: 最大不可以超过8字节(单个通用寄存器的容量). 具体的传参方式规定在<code>Calling Convetion</code>调用规范里. 想要深究的读者, <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2017" rel="external nofollow noopener noreferrer" target="_blank">这里</a>是X64的调用规范.</p><p>刚刚又引入了一个新的寄存器. 准确的说应该是两个:<code>rbp</code>与<code>rsp</code>,分别是<code>Base Pointer</code>栈基指针和<code>Stack Pointer</code>栈顶指针. 顾名思义, <code>rbp</code>始终指向当前栈帧的底部地址,<code>rsp</code>指向顶部地址.</p><p><img src="https://img.vim-cn.com/11/122d5b0b9965577a5213f202609e5277b207a1.gif" alt=""></p><p>按照约定, <code>callee</code>被调用的函数要负责保存和恢复上一级栈帧的基地址. 这就是为什么你在函数的开头结尾总能看到<a href="https://en.wikipedia.org/wiki/Function_prologue" rel="external nofollow noopener noreferrer" target="_blank">这样的代码</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; X64 prologue and epilogue</span><br><span class="line"></span><br><span class="line">push   %rbp</span><br><span class="line">mov    %rsp,%rbp</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pop    %rbp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">; X86 prologue and epilogue</span><br><span class="line"></span><br><span class="line">push   %ebp</span><br><span class="line">mov    %ebp, %esp</span><br><span class="line">sub    %esp, N     </span><br><span class="line">; N Bytes reserved for local varibles</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mov    %esp, %ebp</span><br><span class="line">pop    %ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>通过prologue, 原先的<code>rbp</code>(栈基指针)被保存到栈上, 并把目前的栈顶指针设为栈基指针. 栈底指针更高的地址(加偏移)上保存着参数, 更低的地址(减去偏移)上是预留的局部变量空间.</p><p>Epilogue有终场曲之意, 与开场曲的作用相反, 负责释放使用过的内存(把<code>rsp</code>改回当前<code>rbp</code>),再恢复原先的<code>rbp</code>(前一栈帧的栈基地址).</p><p>Prologue和epilogue之间就是真正的函数功能代码. 调用结束以后, <code>caller</code>调用者需要清除调用前压入栈上的参数.</p><p>说句题外话, 上面的代码可以看出32位和64位平台之间的差别不仅仅是CPU总线位数变宽. 在很多细节上, X64也作出了改进.</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>最初接触到指针的时候, 我被这个名词迷惑了好久. 后来发现可以这么理解:</p><blockquote><p>指针就是内存地址</p></blockquote><p>内存地址是一个类似于<code>size_t</code>的整数, 它的长度等同于机器字长(32位机4字节,64位机8字节), 原因就在于它就是一个内存地址. 试想一下:</p><ul><li>32位机并不能寻址一个64位的地址</li><li>64位机下32位地址不足以表示全部内存空间</li></ul><p>上文我们围绕者函数入口地址讨论了很多. 因为 <strong>指针就是内存地址</strong>, 而这个地址是的内容又是函数, 所以我们可以称函数入口地址为 <strong>函数指针</strong>. 类似的, 如果被指向的内容是一个结构体, 我们就可以称其为结构体指针.</p><h3 id="函数指针-vs-指针函数"><a href="#函数指针-vs-指针函数" class="headerlink" title="函数指针 vs. 指针函数"></a>函数指针 vs. 指针函数</h3><p>“函数””指针”同为名词, 前者修饰后者, 后者才是语义上的重点. 因此:</p><ol><li>函数指针是一个 <strong>指向函数</strong> 的 <strong>指针</strong>.</li><li>指针函数是一个 <strong>返回指针</strong> 的 <strong>函数</strong>.</li></ol><h3 id="值传参-vs-指针传参"><a href="#值传参-vs-指针传参" class="headerlink" title="值传参 vs. 指针传参"></a>值传参 vs. 指针传参</h3><p>C语言默认传参行为是值传递, 具体方式是在栈上创建一个副本. 当传递的数据不是很多, 例如一个整数的时候, 性能表现尚可. 但是这样做存在两个问题:</p><ol><li><p>参数较大(如结构体)时, 涉及到内存读写的复制就会很慢. 当此类函数调用频繁的时候就会出现性能瓶颈.</p></li><li><p>参数不可以被修改. 这是因为函数里对参数的修改实际上作用在了副本上, 原来的值不受影响. (数组除外, 下有解释)</p></li></ol><p>使用指针传参可以解决以上两个问题.</p><ol><li><p>当数据过多时, 我们可以不直接告诉函数所需的数据是什么, 而是告诉函数去哪里寻找这些数据. 这就是用指针传参的思想 - 告诉函数所需数据的内存地址. 由于参数的大小最多只有机器字长, 理论上可通过寄存器来传递, 极大提高速度.</p></li><li><p>由于指针引用的是源数据而不是副本, 所做的更改会被保留. 这就奠定了C用结构体来实现多个返回值的基础. libcurl里有许多这样的例子.</p></li></ol><p>下面两个例程分别演示了这两点.</p><p>第一个例程演示了值传参和指针传参的效率差别<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vector_3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">(vec v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec force;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        do_nothing(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行时间测试(平均值)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m12.753s</span><br><span class="line">user0m12.727s</span><br><span class="line">sys0m0.012s</span><br></pre></td></tr></table></figure><p></p><p>修改为指针传参版本的两个函数和测试数据<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">(vec* v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec* force = (vec*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vec));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        do_nothing(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m10.002s</span><br><span class="line">user0m9.985s</span><br><span class="line">sys0m0.000s</span><br></pre></td></tr></table></figure><p>对比测试数据可以看到指针传参的速度比值传参更快. 当结构体越来越庞大, 这一优势也会越发明显.</p><p>第二个例子演示了数组的传参方式.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show_arr</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR ADDR IN CALLEE\t%p\n"</span>,arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_arr</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> big_array[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR ADDR IN MAIN\t%p\n"</span>, big_array);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If array were passed as copy, this address shall be different</span></span><br><span class="line">    show_arr(big_array);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This gives zero</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR[0] BEFORE MOD\t%d\n"</span>,big_array[<span class="number">0</span>]);  </span><br><span class="line">    mod_arr(big_array);</span><br><span class="line">    <span class="comment">// if array were passed as copy, a[0] would still be zero.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR[0] AFTER MOD\t%d\n"</span>,big_array[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARR ADDR IN MAIN0x7ffd78738200</span><br><span class="line">ARR ADDR IN CALLEE0x7ffd78738200</span><br><span class="line">ARR[0] BEFORE MOD0</span><br><span class="line">ARR[0] AFTER MOD1</span><br></pre></td></tr></table></figure><p></p><p>首先, 我们在主函数里创建了一个数组并打印其地址. 然后将这个数组作为参数传入<code>show_arr</code>. 该函数答应出其数组参数的地址.</p><p>假设数组是按照值传参的方法传递的话, <code>show_arr</code>打印出来的地址应该是值传参创建的副本, 与主函数里打印出来的结果不一致. 但这并非我们所观察到的现象. 这说明数组是以指针方式传递的. (事实上并不奇怪, 数组名实际上也等价于数组的首地址!)</p><p>其次, <code>mod_arr</code>修改了数组里的内容. 如果数组是值传递, 修改好的副本并不会影响到原来的内容, 也就是说第二次print的内容也该是零. 通过指针传参, 内存里的源数据得以被直接修改. 在实际开发中, 结构体指针更常用于这种情况. 多个返回值通过修改结构体指针指向的内容, 而用函数的返回值(按照惯例是整数)来表示函数是否出现异常.</p><p>有兴趣的读者可以自行证明, 通过值传参后修改其参数并不会影响到源数据.</p><h3 id="通过函数指针调用"><a href="#通过函数指针调用" class="headerlink" title="通过函数指针调用"></a>通过函数指针调用</h3><p>前文提到, <code>rip</code>里存储的就是内存地址. 虽说其他的寄存器也可以存放内存地址, <code>rip</code>里的值却有着特殊意义. <strong>这个内存地址的内容将被视为指令来执行</strong>.</p><p>同样在前面的反汇编代码里, 调用<code>abs</code>函数的时候实际是通过跳转到其第一条指令的地址来实现的. 那么我们是否也可以从函数和函数调用的本质出发来重新审视函数呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,hello);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// conventional call</span></span><br><span class="line">    hello();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func pointer call</span></span><br><span class="line">    <span class="keyword">int</span> (*FUNC) () = hello;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, *FUNC);</span><br><span class="line">    FUNC();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x56552f75468a</span><br><span class="line">Hello!</span><br><span class="line">0x56552f75468a</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><p></p><p>这个程序先打印出函数<code>hello</code>的地址, 再分别以普通和函数指针的方式调用一次. 在获取函数指针以后我们打印出来, 和第一句直接用函数名打印出的地址一致. 这再次印证函数名的本质就是函数的入口地址.</p><p>我刚开始接触到函数指针的时候觉得这样调用非常麻烦, 似乎没有什么实际的应用. 不要急, 很快我们就要开始展示函数指针的强大了.</p><h2 id="函数指针应用实例"><a href="#函数指针应用实例" class="headerlink" title="函数指针应用实例"></a>函数指针应用实例</h2><p>最后, 我们回到这篇文章最初的写作动机上.</p><p>这里要实现的是一个尽可能通用的积分函数. 如果要给平方-立方-倒数这三个分别写积分函数, 代码量会大幅增加, 而且这样的写法也不具备通用性: 假设有一天新加了自然对数函数, 则又需要给它写一个专门的积分函数. 但是事实上我们不关心被积函数做了什么, 只要被积函数的返回值即可.</p><p>因此如果把被积函数视作像两个<code>double</code>类型的<code>boundry</code>一样的参数传入, 作为一个通用的函数来调用, 可以大幅简化代码设计.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FUNC)</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, FUNC f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEST FUNCTION LIST</span></span><br><span class="line"><span class="comment">// 1. X^2 - 1,2</span></span><br><span class="line"><span class="comment">// 2. X^3 - 1,2</span></span><br><span class="line"><span class="comment">// 3. 1/X - 1,2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">inverse</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// simpson's rule of integration</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, FUNC f)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (b - a) / <span class="number">6.0</span> * (f(a) + <span class="number">4</span> * f((a + b) / <span class="number">2</span>) + f(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  header</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FUNC\tSTART\tEND\tINTEGRAL\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test table</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SQUARE\t1=\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, square));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CUBE\t1\t2\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, cube));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INVERSE\t1\t2\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, inverse));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FUNCSTARTENDINTEGRAL</span><br><span class="line"></span><br><span class="line">SQUARE122.333333</span><br><span class="line">CUBE123.750000</span><br><span class="line">INVERSE120.694444</span><br></pre></td></tr></table></figure><p></p><p>函数simpson有三个参数:</p><ol><li>积分下边界</li><li>积分上边界</li><li>被积函数</li></ol><p>第三个参数是我们关注的重点. 这里我们就实现了利用函数指针来把一个函数作为参数传递到<code>simpson</code>里. <code>simpson</code>里调用被积函数f的时候, 实际上调用的就是传入的函数指针. 查看<code>simpson</code>函数相关汇编片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">push   %rbp                 ; prologue</span><br><span class="line">mov    %rsp,%rbp            ;</span><br><span class="line">sub    $0x30,%rsp           ;</span><br><span class="line">movsd  %xmm0,-0x8(%rbp)     ; param start</span><br><span class="line">movsd  %xmm1,-0x10(%rbp)    ; param end</span><br><span class="line">mov    %rdi,-0x18(%rbp)     ; param f</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mov    -0x8(%rbp),%rdx      </span><br><span class="line">mov    -0x18(%rbp),%rax     ; func ptr</span><br><span class="line">mov    %rdx,-0x28(%rbp)     </span><br><span class="line">movsd  -0x28(%rbp),%xmm0</span><br><span class="line">callq  *%rax                ; call func</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在调用被积函数前, 函数指针传到<code>rax</code>, 被积函数的参数传到<code>xmm0</code>(浮点寄存器), 然后调用<code>rax</code>里的地址, 即被积函数入口地址.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol start="0"><li>函数就是一段计算机指令的序列</li><li>调用是把rip指向函数起始地址的行为</li><li>函数名 = 函数起始地址</li><li>函数指令位于text段, 运行时数据存放在堆栈</li><li>函数通过栈(X86)或寄存器(x64)传参</li><li>指针就是内存地址</li><li>指针可以高效传参</li><li>函数指针是指向函数的指针</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是自2019中国新年后的第一篇产出. 本以为申请完成后会有很多的空闲时间, 但是因为给自己安排了各种事务, 实际上并不如预想得这么空闲.</p><p>这篇文章最初的写作动机就是在写完simpson积分函数后供自己日后参考的函数指针学习笔记. 不料越写越多, 文章比原来计划的也长了三四倍, 干脆就写成了一篇比较全面的, 给新人指路的文章.</p><p>我最初学C语言是看谭先生的书 - 家里的书柜上也就这么一本. 后来读到<em>The C Programming Language</em>, 相见恨晚. 这本小册子不是面向零基础的读者, 但是对于想要深入了解C语言的程序员十分友好 (毕竟C语言是K&amp;R自己的思想产物). 每个C程序员都该读一读这本手册.</p><p>在这两本书中间我读了<em>Computer System: A Programmer’s Perspective</em>. CMU的大佬操刀编写, 也是该校计算机原理课的教材. 这本书让我系统的接触了汇编语言, 开始熟悉并喜欢上机器级的编程. 后来还有一本<em>自己动手编写操作系统</em>(大概是叫这个名字)给了我上手写汇编和进一步熟悉C语言底层的机会.</p><p>C语言虽说是面向过程的语言, 但目前我的感受, 更恰当的描述是面向机器(或面向内存)的编程语言. 就好像开着手动挡的车的乐趣一样, C语言对机器的操控感是其他高级语言无法比拟的.</p><p>整个现代计算机的体系给我的感觉是”精妙”二字. 无数处精妙的设计让人们从晶体管开始一步一步构建出可以交互的计算机终端. 去年这个时候我在探寻关于<a href="/post/道可道">抽象的力量</a>: 没有了抽象, 拥有无数细节的计算机系统设计将会变得无比繁琐. 一层一层的抽象让人们可以远离底层的细节而专注于创建出更高层的抽象.</p><p>不过有时候回头看看底层的细节, 感受一下字节在电路里的跳动, 也不失为一种乐趣.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/functions-in-C-and-assambly/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

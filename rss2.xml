<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>海森的博客</title>
    <link>https://hisenz.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>海森的博客 - 技术, 料理 &amp; 爵士乐</description>
    <pubDate>Sat, 02 Feb 2019 16:54:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>挑战 | 逆波兰表达式解释器</title>
      <link>https://hisenz.com/post/rpn-challenge/</link>
      <guid>https://hisenz.com/post/rpn-challenge/</guid>
      <pubDate>Sat, 02 Feb 2019 16:54:31 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;挑战 | 逆波兰表达式解释器&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1920年, 逆波兰表示法&lt;code&gt;Reverse Polish Notation&lt;/code&gt;首次被提出. 不同于我们常用的中置表达式, 逆波兰表示法将操作符写在操作数后面, 例如阶乘&lt;code&gt;!&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;逆波兰表示法的这一特性适合使用栈&lt;code&gt;stack&lt;/code&gt;来解析. 这种设计可以减少存储器访问. 因此在1960和1970年代, 逆波兰记法广泛应用于台式和手持计算器.&lt;/p&gt;
&lt;p&gt;在这个挑战里, 你需要编写一个解释器来计算逆波兰表达式, 实现加减乘除四则运算.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="挑战 | 逆波兰表达式解释器"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>1920年, 逆波兰表示法<code>Reverse Polish Notation</code>首次被提出. 不同于我们常用的中置表达式, 逆波兰表示法将操作符写在操作数后面, 例如阶乘<code>!</code>. </p><p>逆波兰表示法的这一特性适合使用栈<code>stack</code>来解析. 这种设计可以减少存储器访问. 因此在1960和1970年代, 逆波兰记法广泛应用于台式和手持计算器.</p><p>在这个挑战里, 你需要编写一个解释器来计算逆波兰表达式, 实现加减乘除四则运算.</p><a id="more"></a><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 7 8 + *</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2 3 * 4 +</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.6</span><br></pre></td></tr></table></figure><h3 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a><strong>完成度</strong></h3><p>本挑战的完成度分为两个等级</p><ol><li>可以解析个位数的操作数</li><li>可以解析多位操作数(包括浮点数)</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>学习栈<code>stack</code>结构与栈的操作</li><li>强化列表与字符串的操作</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%211334&authkey=AGFW-CkDnflM7fw" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基百科: <ul><li><code>reverse_polish_notation.pdf</code></li></ul></li><li>视频 &amp; 英语字幕: <ul><li><code>Reverse Polish Notation and The Stack - Computerphile.m4v</code> </li><li><code>Reverse Polish Notation and The Stack - Computerphile.ass</code></li></ul></li><li>从零开始学Python(第二版)节选<ul><li><code>list_functions.pdf</code></li></ul></li></ol><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol><li>列表对象有两个方法: <ul><li><code>append()</code></li><li><code>pop()</code></li></ul></li><li>字符串对象有个方法:<ul><li><code>strip()</code></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/rpn-challenge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | Brainfuck语言解释器</title>
      <link>https://hisenz.com/post/bf-challenge/</link>
      <guid>https://hisenz.com/post/bf-challenge/</guid>
      <pubDate>Sat, 02 Feb 2019 16:50:41 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;挑战 | Brainfuck语言解释器&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;++++++++++ [&amp;gt;+++++++ &amp;gt;++++++++++ &amp;gt;+++&amp;gt;+&amp;lt;&amp;lt;&amp;lt;&amp;lt;-]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;++.&amp;gt;+.+++++++ ..+++.&amp;gt;++.&amp;lt;&amp;lt;+++++++++++++++ .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;.+++.------ .-------- .&amp;gt;+.&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;BF的工作原理模拟了一台简单的图灵机&lt;code&gt;Turing Machine&lt;/code&gt;. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务. &lt;/p&gt;
&lt;p&gt;虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论&lt;code&gt;Computation Theory&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在这个挑战里, 你需要编写一个解释器来运行BF语言.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="挑战 | Brainfuck语言解释器"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p>BF的工作原理模拟了一台简单的图灵机<code>Turing Machine</code>. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务. </p><p>虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论<code>Computation Theory</code>.</p><p>在这个挑战里, 你需要编写一个解释器来运行BF语言.</p><a id="more"></a><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++</span><br><span class="line">&gt;+&gt;&gt;&gt;&gt;++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">&gt;++++++++++++++++++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;[&gt;[&gt;&gt;&gt;&gt;&gt;&gt;+&gt;</span><br><span class="line">+&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;[&gt;++++++++++[-</span><br><span class="line">&lt;-[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]&gt;[&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;</span><br><span class="line">-]&gt;&gt;[-]]&lt;&lt;]&gt;&gt;&gt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]</span><br><span class="line">&gt;[&lt;&lt;+&gt;&gt;[-]]&lt;&lt;&lt;&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;&gt;[+++++++++++++++++++++++++</span><br><span class="line">+++++++++++++++++++++++.[-]]++++++++++&lt;[-&gt;-&lt;]&gt;++++</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;+&gt;+&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;-]&lt;-[&gt;&gt;.&gt;.&lt;&lt;&lt;</span><br><span class="line">[-]]&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]&lt;&lt;[&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</span><br></pre></td></tr></table></figure><h3 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a><strong>完成度</strong></h3><p>本挑战的完成度分为三个等级</p><ol><li>可以解析<code>+</code>,<code>-</code>,<code>&lt;</code>,<code>&gt;</code>四种操作</li><li>可以解析<code>.</code>,<code>,</code>两种操作</li><li>可以解析循环</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>学习图灵计算模型</li><li>学习ASCII编码</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li><li>理解编程语言的本质</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%211344&authkey=APVSI6GDKYRggf0" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基百科: <ul><li><code>brainfuck.pdf</code></li><li><code>turing_machine.pdf</code></li><li><code>ascii.pdf</code></li></ul></li><li>视频 &amp; 英语字幕: <ul><li><code>How Brainfuck Work.mp4</code> </li><li><code>How Brainfuck Works.ass</code></li></ul></li><li>在线 Brainfuck Visualizer<ul><li><a href="https://fatiherikli.github.io/brainfuck-visualizer/" rel="external nofollow noopener noreferrer" target="_blank">https://fatiherikli.github.io/brainfuck-visualizer/</a></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/bf-challenge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>榜单 | 海森的2018年度歌单</title>
      <link>https://hisenz.com/post/2018-top-10/</link>
      <guid>https://hisenz.com/post/2018-top-10/</guid>
      <pubDate>Sat, 02 Feb 2019 11:53:42 GMT</pubDate>
      <description>
      
        
        
          &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;榜单 | 海森的2018年度歌单&quot;&gt;

&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/aj
        
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="榜单 | 海森的2018年度歌单"><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [        {            name: 'Misty',            artist: 'Ella Fitzgerald',            url:'https://img.vim-cn.com/20/672013f6521c03f281fd018434c85538363cce.mp2',            cover: 'http://p2.music.126.net/_Wfc8snZxj8Wa4dxt9FLWA==/18280480323977240.jpg?param=130y130'        },        {            name: 'Fly Me To The Moon',            artist: 'Elsee',            url:'https://img.vim-cn.com/8c/803d9a1d44200cc09bb6606cfea1182fc9d857.mp2',            cover: 'http://p1.music.126.net/FcGeALZpuINYBne94kUNow==/109951162827593690.jpg?param=130y130'        },        {            name: '1900\'s Madness #2',            artist: 'Ennio Morricone / Amedeo Tommasi',            url:'https://img.vim-cn.com/ae/6f51083bdaa6206a79564f9d71c4ed5440582e.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        },        {            name: '宠爱爵钢版 (Chong Love)',            artist: 'MT1990',            url:'https://img.vim-cn.com/d0/caf6f61778d90c5fb07652db94983f5ffcf7bb.mp2',            cover: 'http://p2.music.126.net/bXkY80qkoLUE7klHTStnjw==/109951162971988949.jpg?param=130y130'        },        {            name: 'Besame Mucho',            artist: 'Lex Vandyke',            url:'https://img.vim-cn.com/86/0e794d5efc880afc38d9d5007d209c07a9ac4c.mp2',            cover: 'https://img.vim-cn.com/b1/3295e1f26e42c39f45adb28eded47690dbdb7e.png'        },        {            name: 'Life Is A Circle',            artist: 'Michale Whalen',            url:'https://img.vim-cn.com/77/4a9e4cab1657ecdbea6d993629ee304d45ab86.mp2',            cover: 'https://img.vim-cn.com/86/d473f1756c0288087425f1782309c00109b4f3.png'        },        {            name: 'Yumeji\'s Theme',            artist: '梅林茂',            url:'https://img.vim-cn.com/4b/3a25010a6e6f1d34ccbc9856efda440a94ea1f.mp2',            cover: 'http://p1.music.126.net/HpKxdM5MWsIqfo-i6RmpdA==/109951163298362339.jpg?param=130y130'        },        {            name: 'Love Theme (天堂电影院)',            artist: 'Henry Mancini',            url:'https://img.vim-cn.com/fa/a83a027dc4ad55d8eef3aaf53fedd78db4f301.mp2',            cover: 'https://img.vim-cn.com/b1/db197519c971ad2faff1bc68b751bc08b81d45.png'        },        {            name: 'Magic Waltz',            artist: 'Amedeo Tommasi',            url:'https://img.vim-cn.com/ac/d77fc506f520de6bfce84bcf7bac6d560240ba.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        },        {            name: 'The Crave',            artist: 'Ennio Morricone',            url:'https://img.vim-cn.com/53/cd0ef355febaf131721e7d01a052ee556a0931.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        }    ]});</script>]]></content:encoded>
      
      <comments>https://hisenz.com/post/2018-top-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>意境 | 末日</title>
      <link>https://hisenz.com/post/alone-in-the-desert/</link>
      <guid>https://hisenz.com/post/alone-in-the-desert/</guid>
      <pubDate>Sat, 02 Feb 2019 05:45:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;现在车抛锚了, 我只能缩在吉普车里. 即便此刻是正午, 蔽天浓烟之下四周依然昏暗.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>现在车抛锚了, 我只能缩在吉普车里. 即便此刻是正午, 蔽天浓烟之下四周依然昏暗.</p><a id="more"></a><p>公路两边, 是无边无际的漫漫黄沙与鬼斧神工的岩石.</p><p>电力通讯网瘫痪, 手机成了废品, 我现在仍然把它放在口袋里也只是”出于情怀”. 唯有自由的电波在空气中毫无痕迹的通过, 此刻这也是与外界通信的唯一方式.</p><p>转动车载电台上的旋钮时候, 除了通联, 偶尔还能收听到一些音乐电台. 这成了逃亡之路上唯一的消遣. 模糊记得, 昨天在加油站修整的时候似乎还能收到七八个台, 今天却只听到两个Classic和R&amp;B. 从其它幸存者的闲聊那里听说, 位于感染区的音乐电台似乎都无人值守维护, 难保设备不出点什么小毛病, 因此戏称”废土电台”. 而我只希望在到达尚未感染的北极圈之前(至少在目前来看还是伊甸园), 一路上还能有音乐陪伴.</p><p>调回到最先发现的音乐台, 方才从调谐钮上移开了手. 我放倒座椅躺下, 盯着触手可及的车顶, 盘算着下一步的行动. 车就是性命. 车(还能工作的车)才能载我到我想去或是我不得不去的地方.</p><p>但是, 就算我可以到达安全区, 在那里汇集的幸存者都会是些什么人呢? “像我这样的亡命之徒吧,”我自嘲道. 比起日益恶化生存条件, 人才是最大的威胁. 因此大多数时候我只是保持着沉默, 仅仅收听其他幸存者的通联而一言不发. 于我而言, 荒无人烟的沙漠才是最安全的地方: 视野开阔, 开车逃跑也容易. 一切都好, 除了食物弹药和汽油奇缺. </p><p>我直起身, 从手套箱里摸出地图. 现在驶离Las Vegas已有30英里, 只要沿着15号公路一路向北, 汽油供应不会有问题. 我只能暗自祈祷先行的逃亡者还有点良心, 这样沿途的废弃加油站里很大概率可以找到汽油和一些工具. 桶装的油是首选, 拎上就可以往车里灌; 废弃的车里也可以偷出一些油, 不过一辆一地拿着虹吸管去挺麻烦, 况且汽油的味道实在不怎么样. </p><p>想到这里, 我顺手拆了一包小甜饼. 几天之前与感染者一场血战之后, 我从超市里搜刮来的水和食物够支持我两个星期, 所以到达目的地前我每天都可以胡吃海喝, 前提是我吃不腻这种草莓果酱小曲奇.</p><p>只要我可以修好我的车.</p><p>不管怎么说, 在这里抛锚的我孤立无援. 没有人可以来帮助我. 走出这里只能依赖自己的勇气, 知识和希望. 一口白兰地下肚, 我把音量调小了些, 披上外套, 伸手去拉开车门.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/alone-in-the-desert/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iFixit: 自己动手维修</title>
      <link>https://hisenz.com/post/ifixit/</link>
      <guid>https://hisenz.com/post/ifixit/</guid>
      <pubDate>Tue, 15 Jan 2019 11:00:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;以下内容翻译自&lt;a href=&quot;https://ifixit.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;iFixit&lt;/a&gt;主页.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>以下内容翻译自<a href="https://ifixit.org/" rel="external nofollow noopener noreferrer" target="_blank">iFixit</a>主页.</p><a id="more"></a><h2 id="为什么选择维修"><a href="#为什么选择维修" class="headerlink" title="为什么选择维修"></a>为什么选择维修</h2><ul><li>省钱</li><li>拯救环境</li><li>更好的掌控自己的设备</li><li>拒绝”一次性经济”</li><li>加入维修运动!</li></ul><h2 id="维修就是自由"><a href="#维修就是自由" class="headerlink" title="维修就是自由"></a>维修就是自由</h2><p>当你购买了设备, 你应当做它的主人. 无论何时何地, 你有权按照你的想法使用它, 更改它, 修复它. 捍卫维修的权利: 这是我们应得的.</p><h2 id="维修创造就业"><a href="#维修创造就业" class="headerlink" title="维修创造就业"></a>维修创造就业</h2><p>尽可能的去维修产品: 翻新过的手机可以出售给其他人; 修复的计算机可以减小人类间的数字鸿沟. 维修工作可以在当地进行.</p><h2 id="维修持续发展"><a href="#维修持续发展" class="headerlink" title="维修持续发展"></a>维修持续发展</h2><p>从前的产品可以使用很久, 而现在的大多只有数年寿命. 维修是环保的. 它使得你爱的产品继续工作而不是被丢弃.</p><h2 id="自己动手修复"><a href="#自己动手修复" class="headerlink" title="自己动手修复"></a>自己动手修复</h2><p>每个人都有维修的需要. 一些人用不上清洁的水是因为他们不知道如何维修水泵. 许多的公司没有向那些独立的维修专家提供可用的零件和手册. 我们尝试改变这一局面.</p><p>iFixit 是一套免费的维修手册. 我们会教你如何维修你的设备. </p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/ifixit/#disqus_thread</comments>
    </item>
    
    <item>
      <title>料理 | 关于舒肥</title>
      <link>https://hisenz.com/post/Sous-Vide/</link>
      <guid>https://hisenz.com/post/Sous-Vide/</guid>
      <pubDate>Sun, 30 Dec 2018 10:46:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;舒肥法&lt;code&gt;Sous Vide&lt;/code&gt;是一种将食材真空低温加热的处理方法. 利用舒肥法可以做出鲜嫩多汁的料理, 把常见的食材潜力尽数发挥. 由于可以把加热过程交给机器控制而无需人工插手, 适合新手以及懒人. &lt;/p&gt;
&lt;p&gt;这篇文章介绍了舒肥法基本要点, 一种低成本DIY舒肥机的方法以及鸡胸肉, 鸡蛋和牛肉的舒肥法烹调示例.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>舒肥法<code>Sous Vide</code>是一种将食材真空低温加热的处理方法. 利用舒肥法可以做出鲜嫩多汁的料理, 把常见的食材潜力尽数发挥. 由于可以把加热过程交给机器控制而无需人工插手, 适合新手以及懒人. </p><p>这篇文章介绍了舒肥法基本要点, 一种低成本DIY舒肥机的方法以及鸡胸肉, 鸡蛋和牛肉的舒肥法烹调示例.</p><a id="more"></a><p><img src="https://s1.ax1x.com/2018/12/30/FhVrpF.jpg" alt="chicken_breast_wide.jpg"></p><h2 id="舒肥-时间的魔法"><a href="#舒肥-时间的魔法" class="headerlink" title="舒肥: 时间的魔法"></a>舒肥: 时间的魔法</h2><p>利用舒肥法可以做出鲜嫩多汁的料理, 把常见的食材潜力尽数发挥. 由于可以把加热过程交给机器控制而无需人工插手, 适合新手以及懒人.</p><p>基本的舒肥方式是保持水温恒定, 食材放入塑料袋抽成真空, 在水里慢慢的低温加热. 事实上只要能近似满足这些条件, 也可以做出相当不错的效果. </p><p>由于舒肥是定温烹调法, 所以不会出现烹调过头的情况. 那么质感的控制由两个变量共同决定: 温度和时间. 我自己总结的经验是:　温度决定食材的熟度, 而时间决定嫩度.</p><ol><li><p>温度<br>我认为温度是一个更重要的变量. 别小看一摄氏度的温差. 哪怕只是一摄氏度的温差都会导致最后食材的熟度差异. 以<a href="https://www.gq.com.tw/mobile/blog/cookingpaul/detail-1783.html" rel="external nofollow noopener noreferrer" target="_blank">舒肥蛋的例子</a>作参考, 61-63摄氏度对应的是不同性状的蛋.</p><blockquote><p>熟度的本质是食物的核心温度. </p></blockquote></li><li><p>时间<br><img src="https://s1.ax1x.com/2018/12/30/FhlXAH.png" alt="curve.png"><br>在温度-时间曲线收敛于设定温度的时候, 食材就基本熟了. 此时时间的重要性凸显了出来. 在煮熟的基础上, 时间越长, 析出的汁水也会越多, 食物也就会变得更加入味, 但不那么嫩.</p></li></ol><h2 id="自制设备"><a href="#自制设备" class="headerlink" title="自制设备"></a>自制设备</h2><p>市售舒肥机售价大致在400人民币起步. 我个人的猜测是因为舒肥法在内地听说过的人不多, 市场也不大, 国内很少有厂家生产. 于是就自然而然的想到可以自制一套舒肥机. 说一句题外话, 我在查找舒肥的中文资料的时候, 大多也都是从台湾的博客/网站上习得的. 台湾在先锋餐饮文学方面的繁荣远超内地.</p><h3 id="电路组成"><a href="#电路组成" class="headerlink" title="电路组成"></a>电路组成</h3><p>最初的设想是用Arduino重新造一个轮子出来. 实现起来并不困难, 但是在核算成本的时候发现温度检测模块的价格并不低廉. 于是直接购入一个温控电源. 这个温控电源有自己的防水温度探头. 当温度低于阀值的时候通导, 加热到另一个温度后断开. </p><p><img src="https://s1.ax1x.com/2018/12/30/Fht3VK.jpg" alt="switch.jpg"></p><p>加热器件采用了600W的电热管. 电热管的作用是维持温度, 因此加热功率不需要很大, 保温足矣.</p><p><img src="https://s1.ax1x.com/2018/12/30/Fhtlb6.jpg" alt="heater.jpg"></p><p>另外据悉市面上的米家电磁炉也有舒肥功能, 售价在300左右. 但是我没有使用过, 不作评价.</p><h3 id="成本核算"><a href="#成本核算" class="headerlink" title="成本核算"></a>成本核算</h3><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">数量</th><th style="text-align:center">价格/人民币</th></tr></thead><tbody><tr><td style="text-align:center">温控电源</td><td style="text-align:center">1</td><td style="text-align:center">29.9</td></tr><tr><td style="text-align:center">电热管</td><td style="text-align:center">1</td><td style="text-align:center">9.8</td></tr><tr><td style="text-align:center">总计</td><td style="text-align:center"></td><td style="text-align:center">37.7</td></tr></tbody></table><h3 id="组合与使用"><a href="#组合与使用" class="headerlink" title="组合与使用"></a>组合与使用</h3><h4 id="装置如图"><a href="#装置如图" class="headerlink" title="装置如图"></a>装置如图</h4><p><img src="https://s1.ax1x.com/2018/12/30/FhlLHe.jpg" alt="equipment.jpg"></p><p>左侧电热管连接至温控电源. 右上角黑色细线是温控电源的探头. </p><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol><li>电热管需要全部浸没在水中. </li><li>电热管工作中请勿触碰.</li><li>工作时电热管间歇通电, 频繁开关是正常现象.</li><li>可以把容器放在保温的箱子里, 盖上盖子以减少热量散失. 这样可以节省能源并减小温度波动.</li><li>温度阀值的设置<br>由于电热管即使断电仍然有余温, 会导致温度的继续上升, 超过食谱规定的温度. 经过实验, 我会把启动温度设定在菜谱温度<code>-0.6</code>摄氏度, 停止温度设定在<code>-0.3</code>摄氏度. 这样可以把温度控制在食谱指定的温度左右.</li><li>放入食材前可以加入热水使温度高于菜谱温度<code>3</code>-<code>4</code>摄氏度.这是应为</li><li>温度探头尽可能贴近食物以测得食物本身的温度.</li><li>舒肥的时间和温度参考请参考文末我收集到的一些表格.</li></ol><h2 id="舒肥鸡胸肉"><a href="#舒肥鸡胸肉" class="headerlink" title="舒肥鸡胸肉"></a>舒肥鸡胸肉</h2><p><img src="https://s1.ax1x.com/2018/12/30/FhVgmR.jpg" alt="chicken_breast_square.jpg"></p><blockquote><p>舒肥鸡胸肉 @ 64摄氏度, 40分钟</p></blockquote><p>用舒肥法处理的鸡胸肉异常嫩且多汁, 没有传统方式烹调过度产生的木渣口感(我觉得柴掉的鸡胸肉就该这么形容).</p><table><thead><tr><th style="text-align:center">食材</th><th style="text-align:center">数量</th><th style="text-align:center">市价/人民币</th></tr></thead><tbody><tr><td style="text-align:center">鸡胸肉</td><td style="text-align:center">500克</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">海盐</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">现磨黑胡椒</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">橄榄油</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">百里香(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">欧芹(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr></tbody></table><p>一整块鸡胸肉, 两面加盐和现磨黑胡椒. 一定不要吝啬, 最好是粗颗粒的海盐. 黑胡椒必须是现磨, 预磨好的颗粒是没有灵魂的! (预研磨的黑胡椒香气不足)</p><p>加入一些Thyme! 有新鲜的百里香最好, 没有的话也可以用干的来替代. 接下来把调理好的鸡胸肉装入塑料袋(保鲜袋或者是专业的袋子), 并加入一些橄榄油以保持嫩的口感. 将袋子浸入冷水中排出空气, 夹住防止漏气.</p><p>装置预热到64摄氏度. 放入舒肥袋, 浸没全部食材. 如果担心滑落可以用夹子夹在容器边上. 确保温度探头尽可能的贴近食物. 启动计时器, 等待40分钟.</p><p>计时停止时取出舒肥袋. 此时鸡胸肉已经可以食用, 切片并浇上舒肥过程中析出的肉汁. 这是个人更偏爱的食用方式.</p><p>如果喜欢烟熏的味道, 可以油煎带来<a href="https://zh.wikipedia.org/zh-hans/%E7%BE%8E%E6%8B%89%E5%BE%B7%E5%8F%8D%E5%BA%94" rel="external nofollow noopener noreferrer" target="_blank">美拉德反应</a>. 加热铸铁锅至高温, 加入橄榄油并放入鸡胸肉. 保持一段时间再翻面, 表面会有漂亮的褐色纹理.</p><p>鸡胸肉通常会作为主菜<code>main course</code>出现, 和土豆泥搭配. 土豆泥的制作又是另一门学问, 如果为了节省时间只能从土豆泥粉调制. 佐餐饮品可以搭配一些口感清淡的酒.</p><h2 id="舒肥蛋"><a href="#舒肥蛋" class="headerlink" title="舒肥蛋"></a>舒肥蛋</h2><p><img src="https://s1.ax1x.com/2018/12/30/FhVsl4.jpg" alt="egg_60.jpg"></p><blockquote><p>舒肥蛋 @ 63摄氏度,一小时</p></blockquote><table><thead><tr><th style="text-align:center">食材</th><th style="text-align:center">数量</th><th style="text-align:center">市价/人民币</th></tr></thead><tbody><tr><td style="text-align:center">鸡蛋</td><td style="text-align:center">1个</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">日式酱油</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">欧芹(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr></tbody></table><p>相对来说舒肥蛋的制作是最简单的. 常温鸡蛋可以直接放入装置中舒肥, 但是因为鸡蛋可能会与电热管直接接触, 我还是推荐用塑料袋排掉气体再放入设备.</p><p><img src="https://s1.ax1x.com/2018/12/30/FhVy6J.jpg" alt="egg_soy.jpg"></p><blockquote><p>舒肥蛋 @ 63摄氏度,一小时</p></blockquote><p>我个人偏好63摄氏度加热1个小时的口感. 直接打在小碟里, 配上一些日式酱油. 蛋黄浓稠, 口感厚重的像芝士, 蛋白软嫰入口即化. 也可以把加热完成的鸡蛋在冷水里放置一会, 鸡蛋入口时的温度会更加适宜.</p><p><img src="https://s1.ax1x.com/2018/12/30/Fh3Uij.md.jpg" alt="egg_60.jpg"></p><blockquote><p>舒肥蛋 @ 63摄氏度,一个半小时</p></blockquote><p>这一组条件下产生的鸡蛋更像是温泉蛋, 蛋白看上去凝固程度更高一些. 更长的舒肥时间会给鸡蛋带来更厚重的口感.</p><h2 id="牛肉"><a href="#牛肉" class="headerlink" title="牛肉"></a>牛肉</h2><p><img src="https://s1.ax1x.com/2018/12/30/Fh60LF.jpg" alt="sous_vide_beef.jpg"></p><blockquote><p>舒肥牛上脑 @ 58摄氏度,40分钟</p></blockquote><p>牛肉的烹调也是一门大学问, 有机会的话单独写一篇文章来分析. 牛肉的处理同鸡胸肉大致相同, 但是我强烈建议最后下锅引发美拉德反应: 这一步可以给牛排注入灵魂!</p><p>传统方式在对付厚度3厘米以下的牛排时表现还不错, 但是面对更厚的牛排就无能为力了, 往往是两面<code>well done</code>而核心<code>rare</code>. 舒肥法在这种情况下的表现极佳, 可以做到内里的熟度一致.</p><p>下面这张图是传统方式制作的牛排:</p><p><img src="https://s1.ax1x.com/2018/12/30/Fh6wsU.jpg" alt="traditional_beef.jpg"></p><blockquote><p>传统方式制作的牛上脑</p></blockquote><p>对比一下可以发现舒肥法制作的牛肉纤维更细致, 汁水更加的丰富, 口感明显更嫩.</p><h2 id="温度时间表"><a href="#温度时间表" class="headerlink" title="温度时间表"></a>温度时间表</h2><p>以下内容收集自网络</p><h3 id="牛肉-1"><a href="#牛肉-1" class="headerlink" title="牛肉"></a>牛肉</h3><p><img src="https://www.cook72.com/wp-content/uploads/2018/06/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-08-06-%E4%B8%8B%E5%8D%885.42.13.png" alt="beef_data"></p><h3 id="禽类"><a href="#禽类" class="headerlink" title="禽类"></a>禽类</h3><p><img src="https://www.cook72.com/wp-content/uploads/2018/05/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-07-%E4%B8%8B%E5%8D%883.08.49.png" alt=""></p><p><img src="https://www.cook72.com/wp-content/uploads/2018/05/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-07-%E4%B8%8B%E5%8D%883.09.06.png" alt=""></p><h3 id="海鲜"><a href="#海鲜" class="headerlink" title="海鲜"></a>海鲜</h3><p><img src="https://www.cook72.com/wp-content/uploads/2018/05/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-08-%E4%B8%8A%E5%8D%8810.38.25-1.png" alt=""></p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/Sous-Vide/#disqus_thread</comments>
    </item>
    
    <item>
      <title>这一年: 2018</title>
      <link>https://hisenz.com/post/2018-summary/</link>
      <guid>https://hisenz.com/post/2018-summary/</guid>
      <pubDate>Mon, 24 Dec 2018 11:17:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;回顾刚刚过去的2018年, 致海森, 也致他的博客.&lt;/p&gt;
&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;开始之前, 与各位分享一曲爵士. 请一边听着它, 一边往下读吧.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>回顾刚刚过去的2018年, 致海森, 也致他的博客.</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>开始之前, 与各位分享一曲爵士. 请一边听着它, 一边往下读吧.<br><a id="more"></a></p><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [{        name: 'Concierto De Aranjuez',        artist: 'Chet Baker & Paul Desmond',        url:'https://img.vim-cn.com/7c/c5d8c3bc552e3254a70ae9d573a575e26e1f45.mp4',        cover: 'http://p1.music.126.net/KSpdMMTs5mMRRzq60hds6A==/724578162716416.jpg'    }]});</script><h2 id="独立博客的第一年"><a href="#独立博客的第一年" class="headerlink" title="独立博客的第一年"></a>独立博客的第一年</h2><p>其实真正的算起来, 开始写博客快有两年了. 最开始的时候在自己的VPS上搭建WordPress, 后来遭受过一次DDoS后就考虑着把平台迁移到GitHub Page. 事实上, 开始使用Hexo标志着我真正开始认真地写博客.</p><p>不过在建站之前, 我是没有写博客的习惯的. 之所以选择自己建立独立博客是因为第三方的平台上限制太多. 况且又有谁愿意把自己文字的命运和一个平台的生死捆绑在一起呢?</p><p>一开始写博客的时候, 我确信没有人会来看. 可能现在也没有. 即便有的话, 我写的文字也多是给搜索引擎的爬虫欣赏的. 孤独地写文字也绝非是什么坏事; 我自己的体验来看, 至少一个人写文字可以让我安静下来. 除了分享, 更多的时候是为了给自己在世界上留下一些痕迹, 偶尔回望的时候, 可以看见当年的自己. </p><p>当我在阅读CSAPP的时候, 我读到了<a href="https://wdxtub.com/" rel="external nofollow noopener noreferrer" target="_blank">小土刀</a>的系列笔记, 进而了解到他的博客. 他是我第一个钦佩的独立博客作者. 大概是从那以后, 我开始有了写自己的独立博客来分享技术和学习成果的念头. </p><p>不像平台, 独立博客没有导流, 流量全看质量. 亦无需紧盯着<code>visit</code>或是<code>follower</code>. 也很自由: 可以说该说的话, 可以做想做的事. </p><p>除了追求宁静, 毅然转向独立站还有一些外在的原因. 近年大环境日益恶化, 可是谁都没有想到这短短一年内竟然倒退成这个地步. 印象最深的是一日某乎更新其隐私政策, 用户可以点击同意或不同意; 选择不同意后重新回到选择界面, 直到用户被”同意”后才可以继续使用产品. 我在企鹅空间嘲讽这一无耻行径, 不料企鹅也是个流氓, 悄无声息的”消失”掉我的声音. </p><p>天下乌鸦是不是一般黑, 我不知道; 国内众厂商不但欺压用户, 往往还狼狈为奸的事实倒是一而再再而三的被实锤.</p><p>不管是自愿想找一个更好的环境, 还是无奈的出走, 总之种种原因让我选择了独立博客. 现在的我很庆幸这一决定.</p><h2 id="年度博文"><a href="#年度博文" class="headerlink" title="年度博文"></a>年度博文</h2><p>这里是今年自认为含金量比较高的几篇文章. 以后的文章(特别是技术文)的文风会向这些优质文章贴近.</p><ol><li><a href="https://hisenz.com/2018/11/02/%E6%B1%87%E7%BC%96%E8%A7%86%E8%A7%92-%E4%B8%8D%E5%90%8C%E4%BC%98%E5%8C%96%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84GCC%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/">汇编视角:不同优化级别下的GCC行为分析</a></li><li><a href="https://hisenz.com/2018/12/06/%E5%88%A9%E7%94%A8%E8%B6%8A%E7%95%8C%E5%92%8C%E6%BA%A2%E5%87%BA-C%E8%AF%AD%E8%A8%80/">利用越界和溢出:C语言</a></li><li><a href="https://hisenz.com/2018/04/20/%E9%81%93%E5%8F%AF%E9%81%93/">道可道 - 关于抽象和”道”的思考</a></li><li><a href="https://hisenz.com/2018/04/21/QR-Code/">二维码的抽象特征分析</a></li></ol><p>上半年开始了关于”道”的探究. 我认为”道”的观念里万物同源, “道”是最高的抽象, 由此”道可道,非常道”. 这种古老的东方哲学流派和计算机似乎存在着某种十分紧密的联系.</p><p>下半年最主要的学习内容是汇编和C语言. 私以为每个优秀的程序员都应该对整个计算机体系深入了解, 能擅长Python也能写汇编, 对于硬件电路的工作原理了然于心. 成为一个优秀的programmer, 我还有很长的路要走.</p><h2 id="关于博客的2019"><a href="#关于博客的2019" class="headerlink" title="关于博客的2019"></a>关于博客的2019</h2><p>在写下这篇文章之前, Hisen’s Blog主要关注技术文和一些个人思考. 接下来的一年里我打算增强这个博客的分享属性. 之后的内容大致分为四块:</p><ol><li>技术文/学习贴</li><li>音乐/乐评</li><li>料理</li><li>生活/思考</li></ol><p>计划里新增的category如下:</p><h3 id="1-增加音乐的推荐-amp-乐评"><a href="#1-增加音乐的推荐-amp-乐评" class="headerlink" title="1. 增加音乐的推荐 &amp; 乐评"></a>1. 增加音乐的推荐 &amp; 乐评</h3><p>我想, 大概会新增一些爵士音乐的分享. 从Louis Armstrong到Terry Callier, 爵士乐在历史上有很多好的作品, 即便在当代也是一样. 许多优秀的作品被传唱演绎了近一百年, 这绝不是今天某些当红的流量明星所能享有的荣耀. 如果我的努力能把大多数国人的审美提高哪怕一点点, 我也是很高兴的.</p><p>爵士是浪漫的, 爵士也是绝望的. 爵士离不开misty. 这也是爵士如此吸引人的原因.</p><p>Hisen’s Blog的早期曾有一些爵士乐评, 可惜在一次事故中丢失了. 说是乐评, 那些文章看起来更像是”大段的推荐描述性文字”. 接下来的一年里, 我将尝试在这个方向上取得一些突破.</p><h3 id="2-增加料理板块"><a href="#2-增加料理板块" class="headerlink" title="2. 增加料理板块"></a>2. 增加料理板块</h3><p>我对食物和烹饪抱有极大的兴趣. 这可能继承自家父. </p><p>在目前的设想里, 这个板块里面主要以图文的形式呈现西餐食物及制作, 不定期的也会收集一些学习资源共享出来. 大多数国人认为西餐的式样和制作都简单, 可能是由于美国快餐文化带来的影响所致. 事实上整个欧洲在过去的数千年内积累下来的餐饮学问和中餐一样博大精深; 从某些层面看, 西餐的细节把控较中式餐点更为严格. </p><p>例如美式早餐的代表<code>Egg Benedict</code>的构成很简单:一片”面包”, 一块”培根”, 一只溏心蛋和荷兰酱. 但是作为”面包”的<code>Muffin</code>分为英式和美式(事实上它是蛋糕的一种); 使用到的培根也是一种火腿; 荷兰酱必须现做, 制作的过程也需要精细控制温度. 假如处理不当, 做出来的<code>Hollandaise Sauce</code>会有蛋腥味.</p><p>分享美食的制作过程和美食本身一样令人愉悦. </p><h3 id="3-修改生活板块"><a href="#3-修改生活板块" class="headerlink" title="3. 修改生活板块"></a>3. 修改生活板块</h3><p>过去这个分类下往往包含了自己的思考和一些对时事的看法. 现在它也将囊括一些Life Hacking的内容. 目前有计划打算低成本实现一台舒肥机, 或许过不久它就会出现在我的博文里.</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>余下的时间里, 继续享受爵士乐大师们的作品吧 : )</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/2018-summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C语言 | Register变量</title>
      <link>https://hisenz.com/post/C%E8%AF%AD%E8%A8%80%E4%B9%8Bregister%E5%8F%98%E9%87%8F-%E8%AF%91%E8%87%AA-The-C-Programming-Language/</link>
      <guid>https://hisenz.com/post/C%E8%AF%AD%E8%A8%80%E4%B9%8Bregister%E5%8F%98%E9%87%8F-%E8%AF%91%E8%87%AA-The-C-Programming-Language/</guid>
      <pubDate>Fri, 14 Dec 2018 05:18:16 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文译自The C Programming Language的4.7章节.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本文译自The C Programming Language的4.7章节.</p><a id="more"></a><p><code>register</code>变量声明会告知编译器该变量会被频繁使用. <code>register</code>变量在运行时存放在机器的寄存器里, 这样生成的程序更短小, 速度也更快. 但是编译器也可能忽略这些建议.</p><p><code>register</code>变量的声明看起来像这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span>  x;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">char</span> c;</span><br></pre></td></tr></table></figure><p>这样的声明只可以用于局部变量和函数的形式参数. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">register</span> <span class="keyword">unsigned</span> m, <span class="keyword">register</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上, 寄存器变量受到一些来自于底层硬件的限制. 每个函数中只有一部分某种类型的变量才会被放在寄存器里. 但是过量的申明并不会造成不良后果, 因为过量的<code>register</code>声明会被编译器忽略. <code>register</code>修饰的变量也不可以被取地址(这个话题在第五章里讨论), 无论是否该变量真的放在寄存器里. 具体的数量和类型限制由特定的机器决定.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/C%E8%AF%AD%E8%A8%80%E4%B9%8Bregister%E5%8F%98%E9%87%8F-%E8%AF%91%E8%87%AA-The-C-Programming-Language/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C语言 | 头文件</title>
      <link>https://hisenz.com/post/C%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6-%E8%AF%91%E8%87%AA%E7%AB%A0%E8%8A%824-5-The-C-Programming-Language/</link>
      <guid>https://hisenz.com/post/C%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6-%E8%AF%91%E8%87%AA%E7%AB%A0%E8%8A%824-5-The-C-Programming-Language/</guid>
      <pubDate>Thu, 13 Dec 2018 12:41:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文译自The C Programming Language的4.5章节.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本文译自The C Programming Language的4.5章节.</p><a id="more"></a><p>现在让我们考虑一下把刚刚编写的计算器程序拆分到几个源文件中, 因为以后每个功能的代码量会越来越多. 我们把主函数写在<code>main.c</code>; <code>push</code>, <code>pop</code>两个函数和其他变量放到<code>stack.c</code>里; <code>getop</code>放在<code>getop.c</code>. 最后把<code>getch</code>和<code>ungetch</code>写到第四个文件<code>getch.c</code>. 之所以把它们分散到不同的源文件中, 是因为他们在实际的工程项目里会被分别编译为库.</p><p>但是有一点要注意: 有些定义和声明同时被几个源文件引用. 我们需要尽可能的把它们集中在一起, 那么在后续的开发中我们只要维护好这个文件就可以了. 我们把这些需要共享的部分放在一个头文件<code>calc.h</code>里, 在需要它们的源文件里<code>#include</code>它. (<code>#include</code> 会在 4.11 章节讲述)</p><p>最终, 这个计算器程序看上去是这样的:</p><p><img src="https://s1.ax1x.com/2018/12/13/FN8LyF.png" alt="FN8LyF.png"></p><p>这么一来, 要么每个源文件只能访问到它需要的信息, 要么有大量的头文件需要维护(在实际工程里这很困难). 权衡利弊,我们选择前者. 在一些中等规模的项目中, 最好的方法往往是通过单一的头文件来包括所有需要被共享的部分; 这也是我们在这里的做法. 在大型的程序中有更多的头文件, 项目结构也需要更加精心的设计. </p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/C%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6-%E8%AF%91%E8%87%AA%E7%AB%A0%E8%8A%824-5-The-C-Programming-Language/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C语言 | 利用越界和溢出</title>
      <link>https://hisenz.com/post/%E5%88%A9%E7%94%A8%E8%B6%8A%E7%95%8C%E5%92%8C%E6%BA%A2%E5%87%BA-C%E8%AF%AD%E8%A8%80/</link>
      <guid>https://hisenz.com/post/%E5%88%A9%E7%94%A8%E8%B6%8A%E7%95%8C%E5%92%8C%E6%BA%A2%E5%87%BA-C%E8%AF%AD%E8%A8%80/</guid>
      <pubDate>Thu, 06 Dec 2018 04:45:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;这篇文章以一道challenge为例, 讲述C语言的越界和溢出. 本篇也是自己的学习记录.&lt;/p&gt;
&lt;p&gt;某日&lt;a href=&quot;https://github.com/rod-lin&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;罗德大佬&lt;/a&gt;在群内分享了一道题:&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这篇文章以一道challenge为例, 讲述C语言的越界和溢出. 本篇也是自己的学习记录.</p><p>某日<a href="https://github.com/rod-lin" rel="external nofollow noopener noreferrer" target="_blank">罗德大佬</a>在群内分享了一道题:</p><a id="more"></a><p>题目与代码如下</p><blockquote><p>What argument(s) to this program will cause it to print “Admin/Debug rights”?</p><p>什么参数可以使得这段程序输出 “Admin/Debug rights”?</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N (20)</span></span><br><span class="line"><span class="keyword">int</span> admin, debug;</span><br><span class="line"><span class="keyword">int</span> histogram[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, h = <span class="number">0</span>;   <span class="comment">//adbm hash</span></span><br><span class="line">    <span class="keyword">while</span> (c = *str++)</span><br><span class="line">        h = c + (h &lt;&lt; <span class="number">6</span>) + (h &lt;&lt; <span class="number">16</span>) - h;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (argc&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>* word = argv[--argc];</span><br><span class="line">        <span class="keyword">int</span> h = hash(word);</span><br><span class="line">        histogram[ (h&lt;<span class="number">0</span>?-h:h) % N ] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (admin || debug) <span class="built_in">puts</span>(<span class="string">"Admin/Debug rights"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h2><p>要打印这个字符串, 就必须修改admin或者debug值.</p><p>首先观察整段代码, 发现没有对这两个变量变量操作的语句. 因此可以肯定不是常规操作. 那么就要考虑利用指针来修改这两个变量里的内容.</p><p>进一步分析, 发现数组histogram和这两个整型变量在内存中是邻接的. 于是很自然的想到利用越界. </p><h2 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h2><p>C语言为了执行效率, 并不会检查数组越界. 这是因为数组的本质是一段连续的内存空间; 其中的每个元素在使用的时候, 都是通过相对数组首元素的偏移地址来查找:</p><p>$$ address_{base} + index * size_{element} $$</p><p>也就是说, 使用数组的<code>[ ]</code>符号实际上访问的就是线性变换过的地址, 比指针使用起来方便一些 - 你不需要记得地址递增递减的size. </p><p>因此只要计算出来的地址是有效地址, 数组越界的时候就不会报错. </p><p>这里由于两个变量的地址在数组之前, 因此我们使用负的index, 就可以访问到这两个变量的位置. 对负数取模, 结果仍是负数; 操纵数组前面地址的index在0到-19这个区间,包括了那两个变量.</p><h2 id="负绝对值"><a href="#负绝对值" class="headerlink" title="负绝对值"></a>负绝对值</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>但是仔细观察index的表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram[ (h&lt;<span class="number">0</span>?-h:h) % N ] ++;</span><br></pre></td></tr></table></figure><p>这里的index是先对h取绝对值再取模, 也就是说index应该只能是正数. </p><p>然而有一种特殊的情况, 使得绝对值函数会输出负数. 让我们来看一下<code>h&lt;0?-h:h</code>的C语言与反汇编代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abs.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译&amp;反汇编<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --no-builtin 排除掉了内建的函数</span></span><br><span class="line">gcc -c abs.c --no-builtin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 反汇编</span></span><br><span class="line">objdump -d abs.o</span><br></pre></td></tr></table></figure></p><p>以下是排版稍作调整的结果, 去掉了偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push   %rbp</span><br><span class="line">mov    %rsp,%rbp</span><br><span class="line">mov    %edi,-0x4(%rbp)  ; pass parameter</span><br><span class="line">mov    -0x4(%rbp),%eax  ; save it in eax</span><br><span class="line">cltd                    ; sign-extend: see below</span><br><span class="line">mov    %edx,%eax        ; </span><br><span class="line">xor    -0x4(%rbp),%eax  ; it depends: see below</span><br><span class="line">sub    %edx,%eax;</span><br><span class="line">pop    %rbp</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>注意第5行指令<code>cltd</code>. 该指令做符号位拓展. 若<code>eax</code>的符号位为0(<code>eax</code>值非负), 则<code>edx</code>全部置0; 否则全部置1. 例如, 当<code>eax</code>为<code>0x7F000000</code>,<code>edx</code>会变成<code>0x00000000</code>.如果<code>eax</code>为<code>0x80000000</code>,<code>edx</code>会变成<code>0xFFFFFFFF</code>. 请参考SO上<a href="https://stackoverflow.com/a/17170478" rel="external nofollow noopener noreferrer" target="_blank">这个回答</a>和维基百科对<a href="https://en.m.wikipedia.org/wiki/Sign_bit" rel="external nofollow noopener noreferrer" target="_blank">符号位的介绍</a>.</p><p>下面我们来看第7-8行的异或和减法:</p><ol><li><p>当参数为正</p><p>此时参数与<code>0x00000000</code>异或, 结果不变;</p><p>随后参数减去<code>0x00000000</code>, 结果仍然不变.</p></li><li><p>参数为负时</p><p>参数与<code>0xFFFFFFFF</code>异或, 相当于取反;</p><p>取反后的参数减去<code>0xFFFFFFFF</code>, 相当于加一.</p></li></ol><p>我们看一下正常情况下, 一个负整数<code>-1024</code>作为参数时的运算过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push   %rbp</span><br><span class="line">mov    %rsp,%rbp</span><br><span class="line">mov    %edi,-0x4(%rbp)  ; 0xfffffc00</span><br><span class="line">mov    -0x4(%rbp),%eax  ; eax = 0x80000000</span><br><span class="line">cltd                    ; edx = 0xffffffff</span><br><span class="line">mov    %edx,%eax        ; eax = 0xffffffff</span><br><span class="line">xor    -0x4(%rbp),%eax  ; eax = 0x3ff</span><br><span class="line">sub    %edx,%eax; eax = 0x400</span><br><span class="line">pop    %rbp</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p><code>0x400</code>也就是<code>1024</code>.</p><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>但是这里有一个问题: 当输入为<code>INT_MIN</code>(十六进制<code>0x80000000</code>,十进制<code>-2147483648</code>)时, 我们来看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push   %rbp</span><br><span class="line">mov    %rsp,%rbp</span><br><span class="line">mov    %edi,-0x4(%rbp)  ; 0x80000000</span><br><span class="line">mov    -0x4(%rbp),%eax  ; eax = 0x80000000</span><br><span class="line">cltd                    ; edx = 0xffffffff</span><br><span class="line">mov    %edx,%eax        ; eax = 0xffffffff</span><br><span class="line">xor    -0x4(%rbp),%eax  ; eax = 0x7fffffff</span><br><span class="line">sub    %edx,%eax; eax = 0x80000000</span><br><span class="line">pop    %rbp</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>输出仍然是负数<code>0x80000000</code>!</p><p>这是为什么呢?</p><p>执行sub指令前, 寄存器和标志位状态如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rax            0x7fffffff2147483647</span><br><span class="line">rdx            0xffffffff4294967295</span><br><span class="line">eflags         0x206[ PF IF ]</span><br></pre></td></tr></table></figure></p><p>执行<code>sub  %edx,%eax</code>后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rax            0x7fffffff2147483647</span><br><span class="line">rdx            0xffffffff4294967295</span><br><span class="line">eflags         0xa87[ CF PF SF IF OF ]</span><br></pre></td></tr></table></figure></p><p>从elflags可以看出到发生了溢出(<code>OF</code>,针对有符号数),进位(<code>CF</code>,针对无符号数),<code>SF</code>位表明运算结果为负数.</p><h2 id="Hash-暴力搜索解"><a href="#Hash-暴力搜索解" class="headerlink" title="Hash 暴力搜索解"></a>Hash 暴力搜索解</h2><p>由于hash的逆运算很困难, 我决定穷举字符串来计算相匹配的hash. 反正输出域只有一个整数, 碰撞应该还是比较容易的.</p><p>这里用pthread实现多线程, 搜索所有可打印ascii字符空间(32-126), 这里只搜索6字节的所有可能. 八线程搜索完的时间大约30分钟. 实际上由于hash可以并行计算, 也可以用显卡来加速运算.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash_threads.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO_WORKER 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c, h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c = *str++)</span><br><span class="line">h = c + (h &lt;&lt; <span class="number">6</span>) + (h &lt;&lt; <span class="number">16</span>) - h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread</span><span class="params">(<span class="keyword">int</span>* no)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = *no;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[RUN] Thread %d.\n"</span>,num); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> str[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">32</span>; i &lt;= <span class="number">126</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> j = <span class="number">32</span>; j &lt;= <span class="number">126</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> k = <span class="number">32</span>; k &lt;= <span class="number">126</span>; k++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> l = <span class="number">32</span>; l &lt;= <span class="number">126</span>; l++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> m = <span class="number">32</span>; m &lt;= <span class="number">126</span>; m++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> n = <span class="number">32</span>+num; n &lt;= <span class="number">126</span>; n+=NO_WORKER)</span><br><span class="line">&#123;</span><br><span class="line">str[<span class="number">0</span>] = i;</span><br><span class="line">str[<span class="number">1</span>] = j;</span><br><span class="line">str[<span class="number">2</span>] = k;</span><br><span class="line">str[<span class="number">3</span>] = l;</span><br><span class="line">str[<span class="number">4</span>] = m;</span><br><span class="line">str[<span class="number">5</span>] = n;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (hash(str) == INT_MIN)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T[%d]\t,%s, &#123; %d, %d, %d, %d, %d, %d, 0 &#125;\n"</span>,</span><br><span class="line">                   num,str,i,j,k,l,m,n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[EXIT] Thread %d.\n"</span>,num); </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nice(<span class="number">-20</span>)) perror(<span class="string">"[INFO] Set priority"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> id[NO_WORKER];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> assign = <span class="number">0</span>;assign &lt; NO_WORKER;assign++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;id[assign],<span class="literal">NULL</span>,(<span class="keyword">void</span> *)thread,&amp;assign))</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"Create pthread error!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> errno;</span><br><span class="line">        &#125; </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NO_WORKER;i++)</span><br><span class="line">        pthread_join(id[i],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O3 -o hash_threads hash_threads.c -lpthread</span><br></pre></td></tr></table></figure></p><p>运行结果(部分)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[RUN] Thread 0.</span><br><span class="line">[RUN] Thread 1.</span><br><span class="line">[RUN] Thread 2.</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">T[1],#,F%9Q, &#123; 35, 44, 70, 37, 57, 81, 0 &#125;</span><br><span class="line">T[1],#fzxji, &#123; 35, 102, 122, 120, 106, 105, 0 &#125;</span><br><span class="line">T[1],#w&#125;[ky, &#123; 35, 119, 125, 91, 107, 121, 0 &#125;</span><br><span class="line">T[5],&apos;&apos;lKlM, &#123; 39, 39, 108, 75, 108, 77, 0 &#125;</span><br><span class="line">T[5],&apos;/kjLE, &#123; 39, 47, 107, 106, 76, 69, 0 &#125;</span><br><span class="line">T[5],&apos;8o.m], &#123; 39, 56, 111, 46, 109, 93, 0 &#125;</span><br><span class="line">T[5],&apos;@nMMU, &#123; 39, 64, 110, 77, 77, 85, 0 &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[EXIT] Thread 2.</span><br><span class="line">[EXIT] Thread 3.</span><br></pre></td></tr></table></figure></p><p>以上的解hash结果取模后均为-8, 也是唯一可能的负数; 直接看来, 向前32字节不可以访问到admin或者debug. 但是编译器可能把变量自动对齐, 这样以来就可以修改到其中部分字节了.</p><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>一开始调试的时候并没有出现期望的运行结果. 上GDB看:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;admin</span><br><span class="line">$2 = (int *) 0x5555557550b0 &lt;admin&gt;</span><br><span class="line">(gdb) p &amp;debug</span><br><span class="line">$3 = (int *) 0x5555557550b4 &lt;debug&gt;</span><br><span class="line">(gdb) p &amp;histogram </span><br><span class="line">$4 = (int (*)[20]) 0x555555755060 &lt;histogram&gt;</span><br></pre></td></tr></table></figure></p><p>真是无语了 搞了半天histogram居然在两个整型变量的后面….<br>请教<a href="https://github.com/qyvlik" rel="external nofollow noopener noreferrer" target="_blank">yv大佬</a>, 查看了<a href="https://stackoverflow.com/a/21818977" rel="external nofollow noopener noreferrer" target="_blank">SO上的回答</a>: undefined behavior. 看来编译器并不是按照变量定义顺序来决定内存里的数据位置.</p><p>于是修改一下变量名为histo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$1 = (int *) 0x555555755060 &lt;admin&gt;</span><br><span class="line">(gdb) p &amp;debug</span><br><span class="line">$2 = (int *) 0x555555755064 &lt;debug&gt;</span><br><span class="line">(gdb) p &amp;histo </span><br><span class="line">$3 = (int (*)[20]) 0x555555755080 &lt;histo&gt;</span><br></pre></td></tr></table></figure><p>我使用的编译器为GCC for Debian 7.3.0, 64位, 修改了变量名以后莫名其妙的成了.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>发现两者内存空间连续, 决定越界</li><li>利用溢出得到负的绝对值输出</li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/%E5%88%A9%E7%94%A8%E8%B6%8A%E7%95%8C%E5%92%8C%E6%BA%A2%E5%87%BA-C%E8%AF%AD%E8%A8%80/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

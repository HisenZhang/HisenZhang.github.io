<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>海森的博客</title>
    <link>https://hisenz.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>海森的博客 - 技术, 料理 &amp; 爵士乐</description>
    <pubDate>Fri, 03 May 2019 02:32:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Mac双系统之删除Windows系统</title>
      <link>https://hisenz.com/post/remove-win-on-mac/</link>
      <guid>https://hisenz.com/post/remove-win-on-mac/</guid>
      <pubDate>Sat, 27 Apr 2019 06:08:16 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客&quot;&gt;&lt;p&gt;很多同学在Mac上通过Bootcamp安装了双系统之后, 由于种种原因, 想要卸载Windows操作系统并释放磁盘空间. 这一篇教程教你如何卸载Windows, 部分内容编译自StackOverflow的&lt;a href=&quot;https://apple.stackexchange.com/a/344481&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;这个回答&lt;/a&gt;.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客"><p>很多同学在Mac上通过Bootcamp安装了双系统之后, 由于种种原因, 想要卸载Windows操作系统并释放磁盘空间. 这一篇教程教你如何卸载Windows, 部分内容编译自StackOverflow的<a href="https://apple.stackexchange.com/a/344481" rel="external nofollow noopener noreferrer" target="_blank">这个回答</a>.</p><a id="more"></a><h2 id="Bootcamp-卸载"><a href="#Bootcamp-卸载" class="headerlink" title="Bootcamp 卸载"></a>Bootcamp 卸载</h2><p>由于Bootcamp分区的特殊性, 不可以直接通过格式化来释放空间.</p><p>在软件列表里打开Bootcamp, 按照向导提示完成. 如果出现了以下错误:</p><blockquote><p>The startup disk cannot be partitioned or restored to a single partition.</p></blockquote><p>请继续阅读以下部分.</p><h2 id="命令行卸载"><a href="#命令行卸载" class="headerlink" title="命令行卸载"></a>命令行卸载</h2><ol start="0"><li><p>打开磁盘实用程序(Disk Utility), 在左侧查看分区. 右侧的详细信息里中如果写有NTFS则表明这是个Windows分区. 记下这个分区的名字(左侧显示的名字).</p></li><li><p>在软件列表里搜索”terminal”, 打开终端(默认白底黑字的窗口).</p></li><li><p>格式化Windows分区:</p><blockquote><p>这一步操作不慎可能导致数据丢失.</p></blockquote><p>依次输入命令(大小写敏感, 每行末尾有回车):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil eraseVolume free none disk0s4</span><br><span class="line">sudo diskutil eraseVolume free none disk0s3</span><br></pre></td></tr></table></figure><p>在输入第一行回车后会询问登录密码. 密码输入的时候没有回显. 输入完成后回车确认.<br>成功的输出看上去像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Started erase on disk0s4 BOOTCAMP</span><br><span class="line">Unmounting disk</span><br><span class="line">Finished erase on disk0</span><br></pre></td></tr></table></figure><p>通常来说只有<code>disk0s3`</code>disk0s4<code>被占用. 少数机器</code>disk0s5`也被占用. 这种情况需要灵活应对, 把上面命令里的分区名改为需要擦除的分区名即可.</p></li><li><p>调整苹果分区大小<br>继续输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil apfs resizeContainer disk0s2 0</span><br></pre></td></tr></table></figure><p>成功的输出看上去像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...(省略)</span><br><span class="line">Growing APFS data structures</span><br><span class="line">Finished APFS operation</span><br></pre></td></tr></table></figure></li><li><p>清理启动文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil mount disk0s1</span><br><span class="line"><span class="built_in">cd</span> /Volumes/EFI/EFI</span><br><span class="line">rm -r Boot</span><br><span class="line">rm -r Microsoft</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">diskutil unmount disk0s1</span><br></pre></td></tr></table></figure><p>rm这一步如果出现Error, 无需采取措施. 这个错误说明安装时候采用的是legacy方式.</p></li><li><p>所有工作已完成. 再次打开Disk Utility来确认刚刚的工作成果.</p></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/remove-win-on-mac/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | 身份证号校验</title>
      <link>https://hisenz.com/post/id-card/</link>
      <guid>https://hisenz.com/post/id-card/</guid>
      <pubDate>Tue, 16 Apr 2019 04:47:05 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客&quot;&gt;&lt;blockquote&gt;&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;2013年开始中国全面使用第二代居民身份证. 目前我国公民身份证号码由18位数字组成: 前6位为&lt;code&gt;地址码&lt;/code&gt;, 第7至14位为&lt;code&gt;出生日期码&lt;/code&gt;, 第15至17位为&lt;code&gt;顺序码&lt;/code&gt;, 第18位为&lt;code&gt;校验码&lt;/code&gt;. 其中第18位&lt;code&gt;校验码&lt;/code&gt;用于快速检测身份证号是否合法(以防止输入错误等情况).&lt;/p&gt;&lt;p&gt;校验过程如下:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;将身份证号逐位乘以对应的&lt;strong&gt;权重&lt;/strong&gt;, 其中&lt;code&gt;X&lt;/code&gt;表示数字&lt;code&gt;10&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;对上一步的结果求和&lt;/li&gt;&lt;li&gt;将校验和对&lt;code&gt;11&lt;/code&gt;取模 &lt;code&gt;mod 11&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果结果为&lt;code&gt;1&lt;/code&gt;, 则该身份证号合法.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上述权重规定于&lt;strong&gt;中华人民共和国国家标准GB11643-1999&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;在这个挑战里, 你需要编写一个程序来检验输入的身份证号是否合法.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>2013年开始中国全面使用第二代居民身份证. 目前我国公民身份证号码由18位数字组成: 前6位为<code>地址码</code>, 第7至14位为<code>出生日期码</code>, 第15至17位为<code>顺序码</code>, 第18位为<code>校验码</code>. 其中第18位<code>校验码</code>用于快速检测身份证号是否合法(以防止输入错误等情况).</p><p>校验过程如下:</p><ol><li>将身份证号逐位乘以对应的<strong>权重</strong>, 其中<code>X</code>表示数字<code>10</code>.</li><li>对上一步的结果求和</li><li>将校验和对<code>11</code>取模 <code>mod 11</code></li><li>如果结果为<code>1</code>, 则该身份证号合法.</li></ol><p>上述权重规定于<strong>中华人民共和国国家标准GB11643-1999</strong>.</p><p>在这个挑战里, 你需要编写一个程序来检验输入的身份证号是否合法.</p><a id="more"></a><p>这里以身份证号<code>11010519491231002X</code>为例, 演示上述过程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序号 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 </span><br><span class="line">权重 07 09 10 05 08 04 02 01 06 03 07 09 10 05 08 04 02 01 </span><br><span class="line">号码 01 01 00 01 00 05 01 09 04 09 01 02 03 01 00 00 02 10</span><br></pre></td></tr></table></figure><ol><li><p>乘以权重并求和<br>$$<br>7\cdot1+9\cdot1+ …+1\cdot10 = 177<br>$$</p></li><li><p>对<code>11</code>取模<br>$$<br>177 \mod11 = 1<br>$$</p></li></ol><p>因为结果为<code>1</code>, 该身份证号有效.</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>从标准输入接收一个身份证号码. 如果该输入是有效号码则输出<code>VALID</code>字样. 否则输出<code>INVALID</code>.</p><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11010519491231002X</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VALID</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">330301194912310021</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INVALID</span><br></pre></td></tr></table></figure><h2 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a>完成度</h2><p>本挑战的完成度分为两个等级</p><ol><li>可以求出校验和</li><li>可以输出样例中的期望结果</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>强化数据类型和类型转换</li><li>强化列表与字符串的操作</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%212317&authkey=ABPeKy9KkwNQM4k" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基文库:<ul><li><code>GB_11643-1999.pdf</code></li></ul></li></ol><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol><li>字符串对象可以视作列表来操作</li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/id-card/#disqus_thread</comments>
    </item>
    
    <item>
      <title>面对无限</title>
      <link>https://hisenz.com/post/The-Graduate/</link>
      <guid>https://hisenz.com/post/The-Graduate/</guid>
      <pubDate>Thu, 11 Apr 2019 05:03:04 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客&quot;&gt;&lt;blockquote&gt;&lt;p&gt;在无穷中, 我们孤独行舟.&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客"><blockquote><p>在无穷中, 我们孤独行舟.</p></blockquote><a id="more"></a><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [{        name: 'The Sound Of Silence',        artist: 'Simon & Garfunkel',        url:'https://img.vim-cn.com/a2/8ce546d286fa7b3e0f74c1e245036ded9e1278.mp2',        cover: 'http://p1.music.126.net/CyphdMz6SkHmpQbacGjGJw==/6647647302210685.jpg?param=130y130'    }]});</script><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>当我看到最近释出的首张黑洞照片, 瞬间一阵恐惧袭来. 尽管存在于同一个宇宙, 这于五千四百万光年外的存在, 是我有生之年永远也无法触及的地方. 倒不如承认它根本就在另外一个与我毫不相干的世界里.</p><p>无穷的距离意味着无穷的不确定性. 当距离遥远, 以至于相对于人类的短暂一生来说是无限之时, 我们还有足够的勇气继续前进吗? 我们还会驶着一叶小舟, 以孤独为伴, 向无穷的虚空空中进发吗?</p><p><img src="https://img.vim-cn.com/24/1b30bba1b7b699a06d7a2f9b96902cd84c1aca.jpg" alt="图片来源 https://live.staticflickr.com/7852/32636958507_973007bd5b_b.jpg"></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>高中的三年快要结束了. 原本以为申请季之后剩下的只有轻松 - 这话放到现在看也确实没错 - 只是伴随着轻松而来的是迷茫. 人生的第一次, 我出现了大片的空白时间. 从读了小学开始便不再有过这样的体验: 每一天总是安排的满满当当, 每一周里也难得有半天的闲暇. 十二年来, 我重复着我认为理所应当的日程. 铁打的安排. 流水的年岁. 年年如此.</p><p>直到这段路走到尽头.</p><p>一如电影毕业生, 危机感向我不断的压来. 我面前是一片空白, 一尘不染; 是一片无限的可能. 在将来的两三个月里是这样, 在未来的四年里也是这样. 前路有无限种可能性, 我尽可以在这两三个月的时间徘徊在这个人生的岔路口,而我最终只能选择其中一条走下去.</p><blockquote><p>I shall be telling this with a sigh<br>Somewhere ages and ages hence:<br>Two roads diverged in a wood, and I–<br>I took the one less traveled by,<br>And that has made all the difference.</p><p>– Robert Frost, <i>The Road Not Taken</i></p></blockquote><p>权衡着机会成本与试错的沉没成本, 我反复问我自己, 我到底该做出怎么样的决定.</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>不过严格来说, 初三时候的我也曾走过一次十字路口, 当时的我大概多少也有这样的担忧. 虽说两三个月也没有折腾出什么成绩, 那却是我这辈子前十八年里心态最佳的时候.</p><p>刚刚上高中那会, 觉得世上本不存在什么不可能的事. 所谓障碍和限制都是人们的臆想或是人为的设置, 仿佛没有物理限制的事情, 我都可以通过直接或者间接的方式达成. 现在三年走下来, 碰壁不少, 也终于觉察到这想法里的些许激进. 当然, 世上仍然没有什么不可能的事, 并且有着”条条大路通罗马”之类的真理在背后撑腰, 然而如果没有合适的资源和天成的机遇, 步骤或许繁杂到难以操作, 其实这么点道理, 老话早已归结了: “做事在人, 成事在天.”</p><p>不过还是要感谢当时的我抱有那样的想法. 因为曾经站在愚昧巅峰, 才有着后来的自信崩塌和绝望低谷. 如果不是如此, 大概这三年来, 我无从获取前进动力.</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>那一段最猖狂的日子里, 我什么都敢叫板: 我不计后果地践行着我认为正确的选择. 我敢于表达自己的价值观. 我伸张正义. 多亏这三年我校领导和家人的”大力栽培”, 我现在做事前都会算计一番, 怎么对自己有利怎么来. 一夜之间, 我从一个哲学家被迫沦为政客.</p><p>高中给我带来最大的收获便是让我见识了黑暗到底可以有多黑暗, 让我初步窥见了”人-脸-钱-权”之间的关系. 世人忘记了”正直”两字怎么写固然很可惜. 然而最不可原谅的是我也忘了这两个字怎么写. 有时看到身边的人, 隔阂感莫名而生, 这令我很不安. 三年前的我看到现在的自己, 会唾弃成什么样?</p><p>活成了自己唾弃的模样, 最惨不过如此.</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>过去的三年也绝非暗无天日, 因为身边有着一群有趣的人. 人是社会动物, 不断受到社会环境的影响. 当身边有更优秀的存在时, 会不由自主的学习对方的优点. (能不能习得则是另一回事).</p><p>他们中的许多人是精神榜样. 和有些人交往的时候让我重新思考一些司空见惯的事物. 有些鼓励我重新开始阅读. 有些人教我为人处世的准则. 这三年间的高光时刻, 都离不开他们. 很幸运碰到了你们.</p><h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2><p>现在诉说的这些种种过往, 都是当时的未知. 时隔三年, 现在我又走到了一个更加错综复杂的岔路口.</p><p>兴奋显然掩盖不住对于无限未来的担忧. 我知道我变了. 也或许没有. 可是纵使再有多的不确定性, 未来在到来的那一刻也会告诉我确切的命运安排.</p><p>在畏惧无穷的时候, 低头看看脚下或许是个不错的主意.</p><p>我将独自穿行于无穷.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/The-Graduate/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | Brainfuck语言解释器</title>
      <link>https://hisenz.com/post/bf-challenge/</link>
      <guid>https://hisenz.com/post/bf-challenge/</guid>
      <pubDate>Mon, 01 Apr 2019 11:53:42 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;挑战 | Brainfuck语言解释器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;++++++++++ [&amp;gt;+++++++ &amp;gt;++++++++++ &amp;gt;+++&amp;gt;+&amp;lt;&amp;lt;&amp;lt;&amp;lt;-]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;++.&amp;gt;+.+++++++ ..+++.&amp;gt;++.&amp;lt;&amp;lt;+++++++++++++++ .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;.+++.------ .-------- .&amp;gt;+.&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;BF的工作原理模拟了一台简单的图灵机&lt;code&gt;Turing Machine&lt;/code&gt;. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务.&lt;/p&gt;&lt;p&gt;虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论&lt;code&gt;Computation Theory&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;在这个挑战里, 你需要编写一个解释器来运行BF语言.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="挑战 | Brainfuck语言解释器"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p>BF的工作原理模拟了一台简单的图灵机<code>Turing Machine</code>. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务.</p><p>虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论<code>Computation Theory</code>.</p><p>在这个挑战里, 你需要编写一个解释器来运行BF语言.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++</span><br><span class="line">&gt;+&gt;&gt;&gt;&gt;++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">&gt;++++++++++++++++++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;[&gt;[&gt;&gt;&gt;&gt;&gt;&gt;+&gt;</span><br><span class="line">+&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;[&gt;++++++++++[-</span><br><span class="line">&lt;-[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]&gt;[&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;</span><br><span class="line">-]&gt;&gt;[-]]&lt;&lt;]&gt;&gt;&gt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]</span><br><span class="line">&gt;[&lt;&lt;+&gt;&gt;[-]]&lt;&lt;&lt;&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;&gt;[+++++++++++++++++++++++++</span><br><span class="line">+++++++++++++++++++++++.[-]]++++++++++&lt;[-&gt;-&lt;]&gt;++++</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;+&gt;+&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;-]&lt;-[&gt;&gt;.&gt;.&lt;&lt;&lt;</span><br><span class="line">[-]]&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]&lt;&lt;[&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</span><br></pre></td></tr></table></figure><h2 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a>完成度</h2><p>本挑战的完成度分为三个等级</p><ol><li>可以解析<code>+</code>,<code>-</code>,<code>&lt;</code>,<code>&gt;</code>四种操作</li><li>可以解析<code>.</code>,<code>,</code>两种操作</li><li>可以解析循环</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>学习图灵计算模型</li><li>学习ASCII编码</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li><li>理解编程语言的本质</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%211344&authkey=APVSI6GDKYRggf0" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基百科:<ul><li><code>brainfuck.pdf</code></li><li><code>turing_machine.pdf</code></li><li><code>ascii.pdf</code></li></ul></li><li>视频 &amp; 英语字幕:<ul><li><code>How Brainfuck Work.mp4</code></li><li><code>How Brainfuck Works.ass</code></li></ul></li><li>在线 Brainfuck Visualizer<ul><li><a href="https://fatiherikli.github.io/brainfuck-visualizer/" rel="external nofollow noopener noreferrer" target="_blank">https://fatiherikli.github.io/brainfuck-visualizer/</a></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/bf-challenge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C语言 | 从内存视角看函数和指针的本质</title>
      <link>https://hisenz.com/post/functions-in-C-and-assambly/</link>
      <guid>https://hisenz.com/post/functions-in-C-and-assambly/</guid>
      <pubDate>Mon, 04 Mar 2019 13:26:29 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;descrription&quot; itemprop=&quot;descrription&quot; content=&quot;海森的博客&quot;&gt;&lt;p&gt;近期在尝试编写一个&lt;code&gt;Simpson&amp;#39;s Rule&lt;/code&gt;近似数值积分的例子, 忽然想到可以把被积函数作为一个参数传入, 使这个积分函数更具有通用性. 这个例子我们会在文末作为实际应用来阐述. 在开始之前, 我们先要讨论一下C语言里的函数到底和函数调用到底是什么.&lt;/p&gt;&lt;p&gt;这篇文章篇幅较长, 且涉及较多示例和证明代码, 建议在桌面设备上阅读. 对于证明代码, 请务必亲自动手编译, 只有真正动手敲过的代码才算有深入理解.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="descrription" itemprop="descrription" content="海森的博客"><p>近期在尝试编写一个<code>Simpson&#39;s Rule</code>近似数值积分的例子, 忽然想到可以把被积函数作为一个参数传入, 使这个积分函数更具有通用性. 这个例子我们会在文末作为实际应用来阐述. 在开始之前, 我们先要讨论一下C语言里的函数到底和函数调用到底是什么.</p><p>这篇文章篇幅较长, 且涉及较多示例和证明代码, 建议在桌面设备上阅读. 对于证明代码, 请务必亲自动手编译, 只有真正动手敲过的代码才算有深入理解.</p><a id="more"></a><p>文章的第一节我们从指令和数据的区别出发, 窥见函数与调用的本质. 第二节分析函数在内存里的位置, 理解程序运行时的内存分布. 第三节在前两板块的基础上描述函数的调用和参数传递之细节. 第四节讨论值传参和指针传参, 包括如何将函数作为参数以传递. 第五节是围绕辛普森法积分例程讲解, 综合前文内容作为函数指针的应用演示.</p><h2 id="函数与调用的本质"><a href="#函数与调用的本质" class="headerlink" title="函数与调用的本质"></a>函数与调用的本质</h2><h3 id="数据-vs-指令"><a href="#数据-vs-指令" class="headerlink" title="数据 vs. 指令"></a>数据 vs. 指令</h3><blockquote><p>函数就是一段计算机指令的序列</p></blockquote><p><img src="https://img.vim-cn.com/ab/0ae6b54603d721196f056c3d377a11ca7028e0.png" alt=""></p><p>在<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture" rel="external nofollow noopener noreferrer" target="_blank">冯诺依曼架构</a>中, 数据和指令存放在一起. 因为这种架构只需要一套存储器, 在计算机工业早期实现成本较低, 也演化成了今天的主流方案.</p><p>程序是数据和指令的集合. 程序里预先定义好的常量是数据. 程序要求预留的空间(变量)也是数据. 注意计算机并不能理解数据.</p><p>指令定义了计算机的行为, 指示计算机如何处理数据. 那么与数据同样是比特的指令有什么特殊性? 那就是指令可以控制计算机来达到我们预期的操作; 只有一些特殊的控制字(指令)可以达到这个目的, 而控制字<code>Command Word</code>和底层的电路设计息息相关.</p><p>其次, 在正常情况下, 计算机的控制权不会转交到数据上. 这是因为数据本身并不能控制计算机; 计算机无法理解这些未知的控制字, 就会触发异常.</p><p>由于冯诺依曼架构下数据和指令存放在一起, 如果因为某种”巧合”, 数据恰好也是对计算机而言有意义的控制字, 那么计算机就会认为这些数据是指令. 利用精心构造的数据来改变计算机的行为, 是一种常见的攻击手法, 如<a href="https://en.wikipedia.org/wiki/Buffer_overflow" rel="external nofollow noopener noreferrer" target="_blank">缓冲区溢出</a>的利用. 这个概念下文我们还会简略提到.</p><p>读到这里我们总结一下上文: 计算机可以执行(理解)的是指令.</p><p><strong>函数就是一段计算机指令的序列</strong>, 这段代码的第一条指令的地址也就是函数的入口地址. 要执行一段指令, 只需要让计算机把控制权转交给这个函数.</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><blockquote><p>调用是把rip指向函数起始地址的行为</p></blockquote><p>我们看一个简单的C语言例子<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">abs</span>(<span class="number">-1024</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译&amp;反汇编<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --no-builtin 排除掉了内建的函数</span></span><br><span class="line">gcc abs.c -o abs --no-builtin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 反汇编</span></span><br><span class="line">objdump -d abs</span><br></pre></td></tr></table></figure><p></p><p>以下摘取相关反汇编片段<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">000000000000061a &lt;abs&gt;:</span><br><span class="line"> 61a:push   %rbp</span><br><span class="line"> 61b:mov    %rsp,%rbp</span><br><span class="line"> 61e:mov    %edi,-0x4(%rbp)  ; pass parameter</span><br><span class="line"> 621:mov    -0x4(%rbp),%eax  ; save it in eax</span><br><span class="line"> 624:cltd                    ; sign-extend</span><br><span class="line"> 625:mov    %edx,%eax        ;</span><br><span class="line"> 627:xor    -0x4(%rbp),%eax  ; tricks</span><br><span class="line"> 62a:sub    %edx,%eax        ; see my previous post</span><br><span class="line"> 62c:pop    %rbp</span><br><span class="line"> 62d:retq   </span><br><span class="line"></span><br><span class="line">000000000000062e &lt;main&gt;:</span><br><span class="line"> 62e:push   %rbp</span><br><span class="line"> 62f:mov    %rsp,%rbp</span><br><span class="line"> 632:mov    $0xfffffc00,%edi ; param -1024</span><br><span class="line"> 637:callq  61a &lt;abs&gt;        ; function call</span><br><span class="line"> 63c:mov    $0x0,%eax        ; return 0</span><br><span class="line"> 641:pop    %rbp             ;</span><br><span class="line"> 642:retq                    ;</span><br></pre></td></tr></table></figure><p></p><p>注: 汇编代码里关于<code>mov</code>与<code>xor</code>的注解请前往我的<a href="/post/利用越界和溢出-C语言/">这篇博文</a>, 此处不深究.</p><p>这里的<code>rip</code>是<code>Instruction Pointer</code>指令指针寄存器, 一个位于CPU的寄存器, 存储着下一条指令的内存地址.</p><p>从高级语言的层面来看, 执行函数的行为叫做<code>call</code>调用. <strong>调用是把rip指向函数起始地址的行为</strong>. 函数起始地址即函数第一条指令所在的地址. 控制权的所在, 就是<code>rip</code>指向的地址.</p><p>默认情况下, rip会顺次指向下一条指令的内存地址. 如X64下<code>pop</code>和<code>push</code>带上参数<code>%rbp</code>以后长度刚好是1字节. 这种情况下执行完一条指令以后, <code>rip</code>直接加一即可. 在一些架构上每条指令长度不等, <code>rip</code>会根据该指令的长度自动递增. 有一些指令, 如<code>call</code>调用指令和<code>jmp</code>强制跳转指令会修改<code>rip</code>寄存器的值, 以实现循环和条件语句. 前者专门用于函数的调用.</p><p>下面我们单步追踪. 假设将要执行的指令位于<code>0x00000637</code>.</p><h4 id="0x00000637"><a href="#0x00000637" class="headerlink" title="0x00000637"></a>0x00000637</h4><p>例子里我们在<code>main</code>中调用了函数<code>abs</code>. 此时rip指向<code>0x00000637</code>.</p><p>反汇编代码中得知<code>abs</code>函数入口位于内存地址<code>0x0000061a</code>. 因此调用<code>abs</code>的汇编代码为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    0x0000061a</span><br></pre></td></tr></table></figure><p>使用<code>jmp</code>的等价版本.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push    %rip</span><br><span class="line">jmp     0x0000061a</span><br></pre></td></tr></table></figure><p>指令<code>call</code>把当前<code>rip</code>寄存器的值(也就是<code>call</code>的下一条指令地址)先保存在栈上, 然后修改值为跳转的目标地址<code>0x0000061a</code>. 这样计算机的控制权就转跳到了这个地址上的指令, 函数开始执行. <code>jmp</code>指令则不会保存上下文而仅仅直接跳转.</p><p>执行完成后, <code>rip</code>值为<code>0x0000061a</code>, 栈上保存的值为<code>0x0000063c</code>. 换言之, 下一条要被执行的指令是<code>abs</code>里的第一条指令<code>push</code>.</p><p><code>abs</code>函数中间过程我们步过, 直到<code>abs</code>的最后一条指令<code>ret</code>. 此时<code>rip</code>指向<code>0x0000062d</code>的<code>ret</code>指令.</p><h4 id="0x0000062d"><a href="#0x0000062d" class="headerlink" title="0x0000062d"></a>0x0000062d</h4><p>函数调用结束的最后需要使用<code>ret</code>指令来恢复原来的地址. <code>ret</code>指令与<code>call</code>指令配对使用. <code>ret</code>的操作过程刚好相反, 从栈上弹出原先保存的地址并写回<code>rip</code>寄存器. 函数调用至此结束.</p><p>栈上保存的地址为<code>0x0000063c</code>, 弹出到<code>rip</code>.</p><p>此时rip指向<code>0x0000063c</code>, 是main函数里<code>call</code>的下一条指令.</p><h2 id="函数的内存位置"><a href="#函数的内存位置" class="headerlink" title="函数的内存位置"></a>函数的内存位置</h2><p>这一节我们一起动手实操, 探究一下运行时堆栈和函数指令存放的位置. 我们需要写一段程序, 这段程序会在不同的位置创建变量并打印出它们的地址.</p><p>注意, 这里的stack和heap都不是准确的地址. 这是因为<a href="https://blog.csdn.net/a511244213/article/details/44994755" rel="external nofollow noopener noreferrer" target="_blank">main函数并非是真正的程序入口</a>; 在这之前还有一些编译器和链接器附上的初始化或是安全保护(如栈保护)代码. 但是这些地址的相对位置足够说明一些事实了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> initialized_var = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> uninitialized_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> local_var_1;</span><br><span class="line">    <span class="keyword">char</span> local_var_2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack 1\t\t%p\n"</span>, &amp;local_var_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack 2\t\t%p\n"</span>, &amp;local_var_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// argc, argv</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv\t\t%p\n"</span>, argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argc\t\t%p\n"</span>, &amp;argc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack address </span></span><br><span class="line">    show_stack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap address</span></span><br><span class="line">    <span class="keyword">char</span> *heap_addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"heap\t\t%p\n"</span>,heap_addr);</span><br><span class="line">    <span class="built_in">free</span>(heap_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uninitialized varibles</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> uninitialized;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uninitialized\t%p\n"</span>, &amp;uninitialized_var);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialized varibles</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> initialized;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"initialized\t%p\n"</span>, &amp;initialized_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// text segment</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"text\t\t%p\n"</span>, show_stack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">argv0x7ffc1d303928</span><br><span class="line">argc0x7ffc1d30382c</span><br><span class="line">stack 10x7ffc1d30380f</span><br><span class="line">stack 20x7ffc1d30380e</span><br><span class="line">heap0x563138330670</span><br><span class="line">uninitialized0x563138326042</span><br><span class="line">initialized0x563138326041</span><br><span class="line">text0x5631381256da</span><br></pre></td></tr></table></figure><p></p><p>对照我们的输出和下面的图示, 逐条分析输出. 分析从高地址向低地址进行.<br><img src="https://img.vim-cn.com/ae/1b6f9da809fafa99be9907cbaf2eab4fc027cc.jpg" alt=""></p><ol><li><p>argc &amp; argv</p><p>这两个变量是主函数的两个参数. argc 是参数个数, argv是参数列表指针, 其中argv[0]指向运行的程序名字符串. 这两个变量是<a href="https://en.wikipedia.org/wiki/Exec_(system_call" rel="external nofollow noopener noreferrer" target="_blank">exec</a>)赋予的. 在图上, 它们位于最高的地址位置.</p></li><li><p>stack 1与stack 2</p><p>栈是由计算机自动分配和释放的, 这套规则由编译器决定. 具体的机器级表示请阅读下一节.</p><p>这里为了演示栈的地址增长方向, 我们在show_stack的栈帧上分配了两个局部变量. 还记得局部变量分配在stack栈上吗? 先分配的变量位于高地址, 后分配的位于低地址.</p><p>栈区的空间相比于堆区来说要小很多.</p></li><li><p>heap</p><p>用malloc手动分配的内存的空间位于堆上. 堆是从低地址向高地址增长的. 这里并没有演示出来, 有兴趣的读者可以动手试一试, 方法和上面观察stack增长方向一致.</p><p>图中可以看到, stack和heap是动态区域. 堆起始地址以下的内存是静态空间, 是<a href="https://en.wikipedia.org/wiki/Exec_(system_call" rel="external nofollow noopener noreferrer" target="_blank">exec</a>)根据<a href="https://baike.baidu.com/item/ELF/7120560" rel="external nofollow noopener noreferrer" target="_blank">ELF</a>从外部存储器加载到内存里的一个映像. 关于exec和ELF的一些细节, 以后会再写一篇文章详细讲述.</p></li><li><p>uninitialized</p><p>这里存放着没有初始化的变量. 也称为bss段. 由exec初始化为零.</p></li><li><p>initialized</p><p>这里存放代码里初始化的变量.</p><p>注意, 这里两个变量都是全局变量, declare在所有函数之外, 使用<code>extern</code>引入. 为什么不直接在主函数里声明呢? 其实如果仔细阅读了stack这一段的话, 你会意识到函数内声明的变量都是分配在栈上的. main函数也是函数, 如果在函数内定义变量, 则会默认在栈上分配空间.</p></li><li><p>text</p><p>文本段, 存放程序代码和字符串常量. 我们打印了函数show_stack的地址(等同于其入口地址).</p><p>如果稍加思索, 就会发现正常情况下rip指向的范围只会在text段里.</p></li></ol><p>综上所述, 函数的指令存放在text段, 运行时函数会操作栈区和堆区. 现在再回头看看第一节里指令和数据的区别, 是否更加的清晰了呢?</p><h2 id="调用规范和参数传递"><a href="#调用规范和参数传递" class="headerlink" title="调用规范和参数传递"></a>调用规范和参数传递</h2><p>在函数调用的本质里我们详细阐述了函数调用在机器层面的表示. 但是细心的读者会发现我们并没有讨论到函数参数的传递. 这里涉及到了<code>callee</code>被调用函数和<code>caller</code>调用者之间的配合.</p><p>C风格的函数传参会在函数调用前, 首先把参数从右到左(从参数列表里的最后一个开始)入栈. 在函数内使用到参数的时候则以<code>%rbp + offset</code>来表示这个特定的参数. 注意这里是<code>+</code>号, 因为 <strong>栈的地址是从高向低增长的</strong>.</p><p>X86默认所有参数从栈上传递, 而X64则把最后四个大小合适的参数<a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2017#parameter-passing" rel="external nofollow noopener noreferrer" target="_blank">通过寄存器传递</a>, 其余的参数同样通过栈传递. 这是因为X64多了好几个寄存器, 且通过寄存器传参的速度远快于内存. 当然这也就对参数的类型做出了限制: 最大不可以超过8字节(单个通用寄存器的容量). 具体的传参方式规定在<code>Calling Convetion</code>调用规范里. 想要深究的读者, <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2017" rel="external nofollow noopener noreferrer" target="_blank">这里</a>是X64的调用规范.</p><p>刚刚又引入了一个新的寄存器. 准确的说应该是两个:<code>rbp</code>与<code>rsp</code>,分别是<code>Base Pointer</code>栈基指针和<code>Stack Pointer</code>栈顶指针. 顾名思义, <code>rbp</code>始终指向当前栈帧的底部地址,<code>rsp</code>指向顶部地址.</p><p><img src="https://img.vim-cn.com/11/122d5b0b9965577a5213f202609e5277b207a1.gif" alt=""></p><p>按照约定, <code>callee</code>被调用的函数要负责保存和恢复上一级栈帧的基地址. 这就是为什么你在函数的开头结尾总能看到<a href="https://en.wikipedia.org/wiki/Function_prologue" rel="external nofollow noopener noreferrer" target="_blank">这样的代码</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; X64 prologue and epilogue</span><br><span class="line"></span><br><span class="line">push   %rbp</span><br><span class="line">mov    %rsp,%rbp</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pop    %rbp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">; X86 prologue and epilogue</span><br><span class="line"></span><br><span class="line">push   %ebp</span><br><span class="line">mov    %ebp, %esp</span><br><span class="line">sub    %esp, N     </span><br><span class="line">; N Bytes reserved for local varibles</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mov    %esp, %ebp</span><br><span class="line">pop    %ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>通过prologue, 原先的<code>rbp</code>(栈基指针)被保存到栈上, 并把目前的栈顶指针设为栈基指针. 栈底指针更高的地址(加偏移)上保存着参数, 更低的地址(减去偏移)上是预留的局部变量空间.</p><p>Epilogue有终场曲之意, 与开场曲的作用相反, 负责释放使用过的内存(把<code>rsp</code>改回当前<code>rbp</code>),再恢复原先的<code>rbp</code>(前一栈帧的栈基地址).</p><p>Prologue和epilogue之间就是真正的函数功能代码. 调用结束以后, <code>caller</code>调用者需要清除调用前压入栈上的参数.</p><p>说句题外话, 上面的代码可以看出32位和64位平台之间的差别不仅仅是CPU总线位数变宽. 在很多细节上, X64也作出了改进.</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>最初接触到指针的时候, 我被这个名词迷惑了好久. 后来发现可以这么理解:</p><blockquote><p>指针就是内存地址</p></blockquote><p>内存地址是一个类似于<code>size_t</code>的整数, 它的长度等同于机器字长(32位机4字节,64位机8字节), 原因就在于它就是一个内存地址. 试想一下:</p><ul><li>32位机并不能寻址一个64位的地址</li><li>64位机下32位地址不足以表示全部内存空间</li></ul><p>上文我们围绕者函数入口地址讨论了很多. 因为 <strong>指针就是内存地址</strong>, 而这个地址是的内容又是函数, 所以我们可以称函数入口地址为 <strong>函数指针</strong>. 类似的, 如果被指向的内容是一个结构体, 我们就可以称其为结构体指针.</p><h3 id="函数指针-vs-指针函数"><a href="#函数指针-vs-指针函数" class="headerlink" title="函数指针 vs. 指针函数"></a>函数指针 vs. 指针函数</h3><p>“函数””指针”同为名词, 前者修饰后者, 后者才是语义上的重点. 因此:</p><ol><li>函数指针是一个 <strong>指向函数</strong> 的 <strong>指针</strong>.</li><li>指针函数是一个 <strong>返回指针</strong> 的 <strong>函数</strong>.</li></ol><h3 id="值传参-vs-指针传参"><a href="#值传参-vs-指针传参" class="headerlink" title="值传参 vs. 指针传参"></a>值传参 vs. 指针传参</h3><p>C语言默认传参行为是值传递, 具体方式是在栈上创建一个副本. 当传递的数据不是很多, 例如一个整数的时候, 性能表现尚可. 但是这样做存在两个问题:</p><ol><li><p>参数较大(如结构体)时, 涉及到内存读写的复制就会很慢. 当此类函数调用频繁的时候就会出现性能瓶颈.</p></li><li><p>参数不可以被修改. 这是因为函数里对参数的修改实际上作用在了副本上, 原来的值不受影响. (数组除外, 下有解释)</p></li></ol><p>使用指针传参可以解决以上两个问题.</p><ol><li><p>当数据过多时, 我们可以不直接告诉函数所需的数据是什么, 而是告诉函数去哪里寻找这些数据. 这就是用指针传参的思想 - 告诉函数所需数据的内存地址. 由于参数的大小最多只有机器字长, 理论上可通过寄存器来传递, 极大提高速度.</p></li><li><p>由于指针引用的是源数据而不是副本, 所做的更改会被保留. 这就奠定了C用结构体来实现多个返回值的基础. libcurl里有许多这样的例子.</p></li></ol><p>下面两个例程分别演示了这两点.</p><p>第一个例程演示了值传参和指针传参的效率差别<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vector_3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">(vec v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec force;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        do_nothing(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行时间测试(平均值)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m12.753s</span><br><span class="line">user0m12.727s</span><br><span class="line">sys0m0.012s</span><br></pre></td></tr></table></figure><p></p><p>修改为指针传参版本的两个函数和测试数据<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">(vec* v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec* force = (vec*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vec));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        do_nothing(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m10.002s</span><br><span class="line">user0m9.985s</span><br><span class="line">sys0m0.000s</span><br></pre></td></tr></table></figure><p>对比测试数据可以看到指针传参的速度比值传参更快. 当结构体越来越庞大, 这一优势也会越发明显.</p><p>第二个例子演示了数组的传参方式.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show_arr</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR ADDR IN CALLEE\t%p\n"</span>,arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_arr</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> big_array[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR ADDR IN MAIN\t%p\n"</span>, big_array);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If array were passed as copy, this address shall be different</span></span><br><span class="line">    show_arr(big_array);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This gives zero</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR[0] BEFORE MOD\t%d\n"</span>,big_array[<span class="number">0</span>]);  </span><br><span class="line">    mod_arr(big_array);</span><br><span class="line">    <span class="comment">// if array were passed as copy, a[0] would still be zero.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR[0] AFTER MOD\t%d\n"</span>,big_array[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARR ADDR IN MAIN0x7ffd78738200</span><br><span class="line">ARR ADDR IN CALLEE0x7ffd78738200</span><br><span class="line">ARR[0] BEFORE MOD0</span><br><span class="line">ARR[0] AFTER MOD1</span><br></pre></td></tr></table></figure><p></p><p>首先, 我们在主函数里创建了一个数组并打印其地址. 然后将这个数组作为参数传入<code>show_arr</code>. 该函数答应出其数组参数的地址.</p><p>假设数组是按照值传参的方法传递的话, <code>show_arr</code>打印出来的地址应该是值传参创建的副本, 与主函数里打印出来的结果不一致. 但这并非我们所观察到的现象. 这说明数组是以指针方式传递的. (事实上并不奇怪, 数组名实际上也等价于数组的首地址!)</p><p>其次, <code>mod_arr</code>修改了数组里的内容. 如果数组是值传递, 修改好的副本并不会影响到原来的内容, 也就是说第二次print的内容也该是零. 通过指针传参, 内存里的源数据得以被直接修改. 在实际开发中, 结构体指针更常用于这种情况. 多个返回值通过修改结构体指针指向的内容, 而用函数的返回值(按照惯例是整数)来表示函数是否出现异常.</p><p>有兴趣的读者可以自行证明, 通过值传参后修改其参数并不会影响到源数据.</p><h3 id="通过函数指针调用"><a href="#通过函数指针调用" class="headerlink" title="通过函数指针调用"></a>通过函数指针调用</h3><p>前文提到, <code>rip</code>里存储的就是内存地址. 虽说其他的寄存器也可以存放内存地址, <code>rip</code>里的值却有着特殊意义. <strong>这个内存地址的内容将被视为指令来执行</strong>.</p><p>同样在前面的反汇编代码里, 调用<code>abs</code>函数的时候实际是通过跳转到其第一条指令的地址来实现的. 那么我们是否也可以从函数和函数调用的本质出发来重新审视函数呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,hello);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// conventional call</span></span><br><span class="line">    hello();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func pointer call</span></span><br><span class="line">    <span class="keyword">int</span> (*FUNC) () = hello;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, *FUNC);</span><br><span class="line">    FUNC();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x56552f75468a</span><br><span class="line">Hello!</span><br><span class="line">0x56552f75468a</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><p></p><p>这个程序先打印出函数<code>hello</code>的地址, 再分别以普通和函数指针的方式调用一次. 在获取函数指针以后我们打印出来, 和第一句直接用函数名打印出的地址一致. 这再次印证函数名的本质就是函数的入口地址.</p><p>我刚开始接触到函数指针的时候觉得这样调用非常麻烦, 似乎没有什么实际的应用. 不要急, 很快我们就要开始展示函数指针的强大了.</p><h2 id="函数指针应用实例"><a href="#函数指针应用实例" class="headerlink" title="函数指针应用实例"></a>函数指针应用实例</h2><p>最后, 我们回到这篇文章最初的写作动机上.</p><p>这里要实现的是一个尽可能通用的积分函数. 如果要给平方-立方-倒数这三个分别写积分函数, 代码量会大幅增加, 而且这样的写法也不具备通用性: 假设有一天新加了自然对数函数, 则又需要给它写一个专门的积分函数. 但是事实上我们不关心被积函数做了什么, 只要被积函数的返回值即可.</p><p>因此如果把被积函数视作像两个<code>double</code>类型的<code>boundry</code>一样的参数传入, 作为一个通用的函数来调用, 可以大幅简化代码设计.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FUNC)</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, FUNC f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEST FUNCTION LIST</span></span><br><span class="line"><span class="comment">// 1. X^2 - 1,2</span></span><br><span class="line"><span class="comment">// 2. X^3 - 1,2</span></span><br><span class="line"><span class="comment">// 3. 1/X - 1,2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">inverse</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// simpson's rule of integration</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, FUNC f)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (b - a) / <span class="number">6.0</span> * (f(a) + <span class="number">4</span> * f((a + b) / <span class="number">2</span>) + f(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  header</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FUNC\tSTART\tEND\tINTEGRAL\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test table</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SQUARE\t1=\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, square));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CUBE\t1\t2\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, cube));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INVERSE\t1\t2\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, inverse));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FUNCSTARTENDINTEGRAL</span><br><span class="line"></span><br><span class="line">SQUARE122.333333</span><br><span class="line">CUBE123.750000</span><br><span class="line">INVERSE120.694444</span><br></pre></td></tr></table></figure><p></p><p>函数simpson有三个参数:</p><ol><li>积分下边界</li><li>积分上边界</li><li>被积函数</li></ol><p>第三个参数是我们关注的重点. 这里我们就实现了利用函数指针来把一个函数作为参数传递到<code>simpson</code>里. <code>simpson</code>里调用被积函数f的时候, 实际上调用的就是传入的函数指针. 查看<code>simpson</code>函数相关汇编片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">push   %rbp                 ; prologue</span><br><span class="line">mov    %rsp,%rbp            ;</span><br><span class="line">sub    $0x30,%rsp           ;</span><br><span class="line">movsd  %xmm0,-0x8(%rbp)     ; param start</span><br><span class="line">movsd  %xmm1,-0x10(%rbp)    ; param end</span><br><span class="line">mov    %rdi,-0x18(%rbp)     ; param f</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mov    -0x8(%rbp),%rdx      </span><br><span class="line">mov    -0x18(%rbp),%rax     ; func ptr</span><br><span class="line">mov    %rdx,-0x28(%rbp)     </span><br><span class="line">movsd  -0x28(%rbp),%xmm0</span><br><span class="line">callq  *%rax                ; call func</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在调用被积函数前, 函数指针传到<code>rax</code>, 被积函数的参数传到<code>xmm0</code>(浮点寄存器), 然后调用<code>rax</code>里的地址, 即被积函数入口地址.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol start="0"><li>函数就是一段计算机指令的序列</li><li>调用是把rip指向函数起始地址的行为</li><li>函数名 = 函数起始地址</li><li>函数指令位于text段, 运行时数据存放在堆栈</li><li>函数通过栈(X86)或寄存器(x64)传参</li><li>指针就是内存地址</li><li>指针可以高效传参</li><li>函数指针是指向函数的指针</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是自2019中国新年后的第一篇产出. 本以为申请完成后会有很多的空闲时间, 但是因为给自己安排了各种事务, 实际上并不如预想得这么空闲.</p><p>这篇文章最初的写作动机就是在写完simpson积分函数后供自己日后参考的函数指针学习笔记. 不料越写越多, 文章比原来计划的也长了三四倍, 干脆就写成了一篇比较全面的, 给新人指路的文章.</p><p>我最初学C语言是看谭先生的书 - 家里的书柜上也就这么一本. 后来读到<em>The C Programming Language</em>, 相见恨晚. 这本小册子不是面向零基础的读者, 但是对于想要深入了解C语言的程序员十分友好 (毕竟C语言是K&amp;R自己的思想产物). 每个C程序员都该读一读这本手册.</p><p>在这两本书中间我读了<em>Computer System: A Programmer’s Perspective</em>. CMU的大佬操刀编写, 也是该校计算机原理课的教材. 这本书让我系统的接触了汇编语言, 开始熟悉并喜欢上机器级的编程. 后来还有一本<em>自己动手编写操作系统</em>(大概是叫这个名字)给了我上手写汇编和进一步熟悉C语言底层的机会.</p><p>C语言虽说是面向过程的语言, 但目前我的感受, 更恰当的描述是面向机器(或面向内存)的编程语言. 就好像开着手动挡的车的乐趣一样, C语言对机器的操控感是其他高级语言无法比拟的.</p><p>整个现代计算机的体系给我的感觉是”精妙”二字. 无数处精妙的设计让人们从晶体管开始一步一步构建出可以交互的计算机终端. 去年这个时候我在探寻关于<a href="/post/道可道">抽象的力量</a>: 没有了抽象, 拥有无数细节的计算机系统设计将会变得无比繁琐. 一层一层的抽象让人们可以远离底层的细节而专注于创建出更高层的抽象.</p><p>不过有时候回头看看底层的细节, 感受一下字节在电路里的跳动, 也不失为一种乐趣.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/functions-in-C-and-assambly/#disqus_thread</comments>
    </item>
    
    <item>
      <title>随想 | 晨间爵士</title>
      <link>https://hisenz.com/post/jazz-in-morning/</link>
      <guid>https://hisenz.com/post/jazz-in-morning/</guid>
      <pubDate>Mon, 04 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客 | 晨间爵士&quot;&gt;&lt;p&gt;并非所有爵士都属于黑夜. 在晨间迷雾里, 它美的令人窒息.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客 | 晨间爵士"><p>并非所有爵士都属于黑夜. 在晨间迷雾里, 它美的令人窒息.</p><a id="more"></a><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    fixed: true,    autoplay: true,    audio: [        {            name: 'Misty',            artist: 'Ella Fitzgerald',            url:'https://img.vim-cn.com/20/672013f6521c03f281fd018434c85538363cce.mp2',            cover: 'http://p2.music.126.net/_Wfc8snZxj8Wa4dxt9FLWA==/18280480323977240.jpg?param=130y130'        },        {            name: 'I Loves You Porgy',            artist: 'Keith Jarrett',            url:'https://img.vim-cn.com/21/bb7f0aa62889d6076cf2e69718882ec4f6b394.mp2',            cover: 'https://img.vim-cn.com/be/9fbd144b5e22b2e1b0fada97036b4f7f5af788.jpg'        },        {            name: 'Paris Blues',            artist: 'Terry Callier',            url:'https://img.vim-cn.com/88/6bfd1796f1071dec7499f9b3ac3de2753819f2.mp2',            cover: '//y.gtimg.cn/music/photo_new/T002R300x300M0000010wTyL3QoWLQ.jpg?max_age=2592000'        }    ]});</script><h2 id="Misty"><a href="#Misty" class="headerlink" title="Misty"></a>Misty</h2><p>可以横跨三个八度音阶的她, 音准与节奏无可挑剔. “高如黃鶯出谷，低如湖水沈靜”</p><p>百年前降临人间的 Ella Fitzgerald 歌声是有魔力的. 人们说, 即便是同一首歌, 在不同的场合时间下聆听, 她的演绎也不尽相同.</p><blockquote><p>Walk my way,<br>And a thousand violins begin to play,<br>Or it might be the sound of your hello,<br>That music I hear,<br>I get misty, the moment you’re near.</p></blockquote><p>简单清澈的钢琴伴奏与她的歌声, 晨间听来如此干净, 夜晚却传递出一丝忧伤.</p><p>清晨听, 舒缓安抚的声音带来宁静, 仿佛撑着小船穿梭于水面上的薄雾.<br>黑夜听, 忧郁沧桑, 有如一位老妇人平静讲述她传奇的一生.</p><p>故有诗云</p><blockquote><p>夜深忽梦少年事<br>唯梦闲人不梦君</p></blockquote><h2 id="I-Loves-You-Porgy"><a href="#I-Loves-You-Porgy" class="headerlink" title="I Loves You Porgy"></a>I Loves You Porgy</h2><p>一首写在水上的诗, 钢琴表现的轻盈且宁静.</p><blockquote><p>Bess: I loves you, Progy.<br>Porgy: Bess, you is my women now.</p></blockquote><p>本曲出自音乐剧 Progy and Bess. 剧中, 生活在社会底层的两人并没有受过教育, 因此语法糟糕. 听说这部音乐剧评价不错, 我已经安排上观赏日程.</p><h2 id="Paris-Blues"><a href="#Paris-Blues" class="headerlink" title="Paris Blues"></a>Paris Blues</h2><p>个人非常喜爱的一首爵士. 我的<a href="/about">About页面</a>里也嵌入了这首歌. 在迷茫和忧郁的早晨, 隔着咖啡杯上氤氲雾气望向白茫茫的窗外, 是 Paris Blues 带给我的感觉.</p><blockquote><p>She’s out of my mind<br>I’m out of my head</p></blockquote><p>Terry Callier 的嗓音有厚度有沧桑, 和 Louis Armstrong 有几分内在的相像. 可惜当我知道这首爵士的时候, 他已经去天堂唱歌了.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/jazz-in-morning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>榜单 | 海森的2018年度歌单</title>
      <link>https://hisenz.com/post/2018-top-10/</link>
      <guid>https://hisenz.com/post/2018-top-10/</guid>
      <pubDate>Sat, 02 Feb 2019 11:53:42 GMT</pubDate>
      <description>
      
        
        
          &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;榜单 | 海森的2018年度歌单&quot;&gt;&lt;p&gt;这里是海森2018年的TOP10歌单. 其中一些作品非常值得我在日后细细撰写乐评.&lt;/p&gt;&lt;p&gt;&lt;link rel=&quot;sty
        
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="榜单 | 海森的2018年度歌单"><p>这里是海森2018年的TOP10歌单. 其中一些作品非常值得我在日后细细撰写乐评.</p><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [        {            name: 'Misty',            artist: 'Ella Fitzgerald',            url:'https://img.vim-cn.com/20/672013f6521c03f281fd018434c85538363cce.mp2',            cover: 'http://p2.music.126.net/_Wfc8snZxj8Wa4dxt9FLWA==/18280480323977240.jpg?param=130y130'        },        {            name: 'Fly Me To The Moon',            artist: 'Elsee',            url:'https://img.vim-cn.com/8c/803d9a1d44200cc09bb6606cfea1182fc9d857.mp2',            cover: 'http://p1.music.126.net/FcGeALZpuINYBne94kUNow==/109951162827593690.jpg?param=130y130'        },        {            name: '1900\'s Madness #2',            artist: 'Ennio Morricone / Amedeo Tommasi',            url:'https://img.vim-cn.com/ae/6f51083bdaa6206a79564f9d71c4ed5440582e.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        },        {            name: '宠爱爵钢版 (Chong Love)',            artist: 'MT1990',            url:'https://img.vim-cn.com/d0/caf6f61778d90c5fb07652db94983f5ffcf7bb.mp2',            cover: 'http://p2.music.126.net/bXkY80qkoLUE7klHTStnjw==/109951162971988949.jpg?param=130y130'        },        {            name: 'Besame Mucho',            artist: 'Lex Vandyke',            url:'https://img.vim-cn.com/86/0e794d5efc880afc38d9d5007d209c07a9ac4c.mp2',            cover: 'https://img.vim-cn.com/b1/3295e1f26e42c39f45adb28eded47690dbdb7e.png'        },        {            name: 'Life Is A Circle',            artist: 'Michale Whalen',            url:'https://img.vim-cn.com/77/4a9e4cab1657ecdbea6d993629ee304d45ab86.mp2',            cover: 'https://img.vim-cn.com/86/d473f1756c0288087425f1782309c00109b4f3.png'        },        {            name: 'Yumeji\'s Theme',            artist: '梅林茂',            url:'https://img.vim-cn.com/4b/3a25010a6e6f1d34ccbc9856efda440a94ea1f.mp2',            cover: 'http://p1.music.126.net/HpKxdM5MWsIqfo-i6RmpdA==/109951163298362339.jpg?param=130y130'        },        {            name: 'Love Theme (天堂电影院)',            artist: 'Henry Mancini',            url:'https://img.vim-cn.com/fa/a83a027dc4ad55d8eef3aaf53fedd78db4f301.mp2',            cover: 'https://img.vim-cn.com/b1/db197519c971ad2faff1bc68b751bc08b81d45.png'        },        {            name: 'Magic Waltz',            artist: 'Amedeo Tommasi',            url:'https://img.vim-cn.com/ac/d77fc506f520de6bfce84bcf7bac6d560240ba.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        },        {            name: 'The Crave',            artist: 'Ennio Morricone',            url:'https://img.vim-cn.com/53/cd0ef355febaf131721e7d01a052ee556a0931.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        }    ]});</script>]]></content:encoded>
      
      <comments>https://hisenz.com/post/2018-top-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>意境 | 末日</title>
      <link>https://hisenz.com/post/alone-in-the-desert/</link>
      <guid>https://hisenz.com/post/alone-in-the-desert/</guid>
      <pubDate>Sat, 02 Feb 2019 05:45:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;现在车抛锚了, 我只能缩在吉普车里. 即便此刻是正午, 蔽天浓烟之下四周依然昏暗.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>现在车抛锚了, 我只能缩在吉普车里. 即便此刻是正午, 蔽天浓烟之下四周依然昏暗.</p><a id="more"></a><p>公路两边, 是无边无际的漫漫黄沙与鬼斧神工的岩石.</p><p>电力通讯网瘫痪, 手机成了废品, 我现在仍然把它放在口袋里也只是”出于情怀”. 唯有自由的电波在空气中毫无痕迹的通过, 此刻这也是与外界通信的唯一方式.</p><p>转动车载电台上的旋钮时候, 除了通联, 偶尔还能收听到一些音乐电台. 这成了逃亡之路上唯一的消遣. 模糊记得, 昨天在加油站修整的时候似乎还能收到七八个台, 今天却只听到两个Classic和R&amp;B. 从其它幸存者的闲聊那里听说, 位于感染区的音乐电台似乎都无人值守维护, 难保设备不出点什么小毛病, 因此戏称”废土电台”. 而我只希望在到达尚未感染的北极圈之前(至少在目前来看还是伊甸园), 一路上还能有音乐陪伴.</p><p>调回到最先发现的音乐台, 方才从调谐钮上移开了手. 我放倒座椅躺下, 盯着触手可及的车顶, 盘算着下一步的行动. 车就是性命. 车(还能工作的车)才能载我到我想去或是我不得不去的地方.</p><p>但是, 就算我可以到达安全区, 在那里汇集的幸存者都会是些什么人呢? “像我这样的亡命之徒吧,”我自嘲道. 比起日益恶化生存条件, 人才是最大的威胁. 因此大多数时候我只是保持着沉默, 仅仅收听其他幸存者的通联而一言不发. 于我而言, 荒无人烟的沙漠才是最安全的地方: 视野开阔, 开车逃跑也容易. 一切都好, 除了食物弹药和汽油奇缺.</p><p>我直起身, 从手套箱里摸出地图. 现在驶离Las Vegas已有30英里, 只要沿着15号公路一路向北, 汽油供应不会有问题. 我只能暗自祈祷先行的逃亡者还有点良心, 这样沿途的废弃加油站里很大概率可以找到汽油和一些工具. 桶装的油是首选, 拎上就可以往车里灌; 废弃的车里也可以偷出一些油, 不过一辆一地拿着虹吸管去挺麻烦, 况且汽油的味道实在不怎么样.</p><p>想到这里, 我顺手拆了一包小甜饼. 几天之前与感染者一场血战之后, 我从超市里搜刮来的水和食物够支持我两个星期, 所以到达目的地前我每天都可以胡吃海喝, 前提是我吃不腻这种草莓果酱小曲奇.</p><p>只要我可以修好我的车.</p><p>不管怎么说, 在这里抛锚的我孤立无援. 没有人可以来帮助我. 走出这里只能依赖自己的勇气, 知识和希望. 一口白兰地下肚, 我把音量调小了些, 披上外套, 伸手去拉开车门.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/alone-in-the-desert/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | 逆波兰表达式解释器</title>
      <link>https://hisenz.com/post/rpn-challenge/</link>
      <guid>https://hisenz.com/post/rpn-challenge/</guid>
      <pubDate>Sat, 02 Feb 2019 04:50:41 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;挑战 | 逆波兰表达式解释器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;1920年, 逆波兰表示法&lt;code&gt;Reverse Polish Notation&lt;/code&gt;首次被提出. 不同于我们常用的中置表达式, 逆波兰表示法将操作符写在操作数后面, 例如阶乘&lt;code&gt;!&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;逆波兰表示法的这一特性适合使用栈&lt;code&gt;stack&lt;/code&gt;来解析. 这种设计可以减少存储器访问. 因此在1960和1970年代, 逆波兰记法广泛应用于台式和手持计算器.&lt;/p&gt;&lt;p&gt;在这个挑战里, 你需要编写一个解释器来计算逆波兰表达式, 实现加减乘除四则运算.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="挑战 | 逆波兰表达式解释器"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>1920年, 逆波兰表示法<code>Reverse Polish Notation</code>首次被提出. 不同于我们常用的中置表达式, 逆波兰表示法将操作符写在操作数后面, 例如阶乘<code>!</code>.</p><p>逆波兰表示法的这一特性适合使用栈<code>stack</code>来解析. 这种设计可以减少存储器访问. 因此在1960和1970年代, 逆波兰记法广泛应用于台式和手持计算器.</p><p>在这个挑战里, 你需要编写一个解释器来计算逆波兰表达式, 实现加减乘除四则运算.</p><a id="more"></a><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 7 8 + *</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2 3 * 4 +</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.6</span><br></pre></td></tr></table></figure><h2 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a>完成度</h2><p>本挑战的完成度分为两个等级</p><ol><li>可以解析个位数的操作数</li><li>可以解析多位操作数(包括浮点数)</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>学习栈<code>stack</code>结构与栈的操作</li><li>强化列表与字符串的操作</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%211334&authkey=AGFW-CkDnflM7fw" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基百科:<ul><li><code>reverse_polish_notation.pdf</code></li></ul></li><li>视频 &amp; 英语字幕:<ul><li><code>Reverse Polish Notation and The Stack - Computerphile.m4v</code></li><li><code>Reverse Polish Notation and The Stack - Computerphile.ass</code></li></ul></li><li>从零开始学Python(第二版)节选<ul><li><code>list_functions.pdf</code></li></ul></li></ol><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol><li>列表对象有两个方法:<ul><li><code>append()</code></li><li><code>pop()</code></li></ul></li><li>字符串对象有个方法:<ul><li><code>strip()</code></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/rpn-challenge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iFixit: 自己动手维修</title>
      <link>https://hisenz.com/post/ifixit/</link>
      <guid>https://hisenz.com/post/ifixit/</guid>
      <pubDate>Tue, 15 Jan 2019 11:00:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;以下内容翻译自&lt;a href=&quot;https://ifixit.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;iFixit&lt;/a&gt;主页.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>以下内容翻译自<a href="https://ifixit.org/" rel="external nofollow noopener noreferrer" target="_blank">iFixit</a>主页.</p><a id="more"></a><h2 id="为什么选择维修"><a href="#为什么选择维修" class="headerlink" title="为什么选择维修"></a>为什么选择维修</h2><ul><li>省钱</li><li>拯救环境</li><li>更好的掌控自己的设备</li><li>拒绝”一次性经济”</li><li>加入维修运动!</li></ul><h2 id="维修就是自由"><a href="#维修就是自由" class="headerlink" title="维修就是自由"></a>维修就是自由</h2><p>当你购买了设备, 你应当做它的主人. 无论何时何地, 你有权按照你的想法使用它, 更改它, 修复它. 捍卫维修的权利: 这是我们应得的.</p><h2 id="维修创造就业"><a href="#维修创造就业" class="headerlink" title="维修创造就业"></a>维修创造就业</h2><p>尽可能的去维修产品: 翻新过的手机可以出售给其他人; 修复的计算机可以减小人类间的数字鸿沟. 维修工作可以在当地进行.</p><h2 id="维修持续发展"><a href="#维修持续发展" class="headerlink" title="维修持续发展"></a>维修持续发展</h2><p>从前的产品可以使用很久, 而现在的大多只有数年寿命. 维修是环保的. 它使得你爱的产品继续工作而不是被丢弃.</p><h2 id="自己动手修复"><a href="#自己动手修复" class="headerlink" title="自己动手修复"></a>自己动手修复</h2><p>每个人都有维修的需要. 一些人用不上清洁的水是因为他们不知道如何维修水泵. 许多的公司没有向那些独立的维修专家提供可用的零件和手册. 我们尝试改变这一局面.</p><p>iFixit 是一套免费的维修手册. 我们会教你如何维修你的设备.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/ifixit/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

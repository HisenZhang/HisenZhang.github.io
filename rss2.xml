<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>海森的博客</title>
    <link>https://hisenz.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>海森的博客 - 技术, 料理 &amp; 爵士乐</description>
    <pubDate>Fri, 12 Apr 2019 06:49:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>面对无限</title>
      <link>https://hisenz.com/post/The-Graduate/</link>
      <guid>https://hisenz.com/post/The-Graduate/</guid>
      <pubDate>Thu, 11 Apr 2019 05:03:04 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客&quot;&gt;&lt;blockquote&gt;&lt;p&gt;在无穷中, 我们孤独行舟.&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客"><blockquote><p>在无穷中, 我们孤独行舟.</p></blockquote><a id="more"></a><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [{        name: 'The Sound Of Silence',        artist: 'Simon & Garfunkel',        url:'https://img.vim-cn.com/a2/8ce546d286fa7b3e0f74c1e245036ded9e1278.mp2',        cover: 'http://p1.music.126.net/CyphdMz6SkHmpQbacGjGJw==/6647647302210685.jpg?param=130y130'    }]});</script><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>当我看到最近释出的首张黑洞照片, 瞬间一阵恐惧袭来. 尽管存在于同一个宇宙, 这于五千四百万光年外的存在, 是我有生之年永远也无法触及的地方. 倒不如承认它根本就在另外一个与我毫不相干的世界里.</p><p>无穷的距离意味着无穷的不确定性. 当距离遥远, 以至于相对于人类的短暂一生来说是无限之时, 我们还有足够的勇气继续前进吗? 我们还会驶着一叶小舟, 以孤独为伴, 向无穷的虚空空中进发吗?</p><p><img src="https://img.vim-cn.com/24/1b30bba1b7b699a06d7a2f9b96902cd84c1aca.jpg" alt="图片来源 https://live.staticflickr.com/7852/32636958507_973007bd5b_b.jpg"></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>高中的三年快要结束了. 原本以为申请季之后剩下的只有轻松 - 这话放到现在看也确实没错 - 只是伴随着轻松而来的是迷茫. 人生的第一次, 我出现了大片的空白时间. 从读了小学开始便不再有过这样的体验: 每一天总是安排的满满当当, 每一周里也难得有半天的闲暇. 十二年来, 我重复着我认为理所应当的日程. 铁打的安排. 流水的年岁. 年年如此.</p><p>直到这段路走到尽头.</p><p>一如电影毕业生, 危机感向我不断的压来. 我面前是一片空白, 一尘不染; 是一片无限的可能. 在将来的两三个月里是这样, 在未来的四年里也是这样. 前路有无限种可能性, 我尽可以在这两三个月的时间徘徊在这个人生的岔路口,而我最终只能选择其中一条走下去.</p><blockquote><p>I shall be telling this with a sigh<br>Somewhere ages and ages hence:<br>Two roads diverged in a wood, and I–<br>I took the one less traveled by,<br>And that has made all the difference.</p><p>– Robert Frost, <i>The Road Not Taken</i></p></blockquote><p>权衡着机会成本与试错的沉没成本, 我反复问我自己, 我到底该做出怎么样的决定.</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>不过严格来说, 初三时候的我也曾走过一次十字路口, 当时的我大概多少也有这样的担忧. 虽说两三个月也没有折腾出什么成绩, 那却是我这辈子前十八年里心态最佳的时候.</p><p>刚刚上高中那会, 觉得世上本不存在什么不可能的事. 所谓障碍和限制都是人们的臆想或是人为的设置, 仿佛没有物理限制的事情, 我都可以通过直接或者间接的方式达成. 现在三年走下来, 碰壁不少, 也终于觉察到这想法里的些许激进. 当然, 世上仍然没有什么不可能的事, 并且有着”条条大路通罗马”之类的真理在背后撑腰, 然而如果没有合适的资源和天成的机遇, 步骤或许繁杂到难以操作, 其实这么点道理, 老话早已归结了: “做事在人, 成事在天.”</p><p>不过还是要感谢当时的我抱有那样的想法. 因为曾经站在愚昧巅峰, 才有着后来的自信崩塌和绝望低谷. 如果不是如此, 大概这三年来, 我无从获取前进动力.</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>那一段最猖狂的日子里, 我什么都敢叫板: 我不计后果地践行着我认为正确的选择. 我敢于表达自己的价值观. 我伸张正义. 多亏这三年我校领导和家人的”大力栽培”, 我现在做事前都会算计一番, 怎么对自己有利怎么来. 一夜之间, 我从一个哲学家被迫沦为政客.</p><p>高中给我带来最大的收获便是让我见识了黑暗到底可以有多黑暗, 让我初步窥见了”人-脸-钱-权”之间的关系. 世人忘记了”正直”两字怎么写固然很可惜. 然而最不可原谅的是我也忘了这两个字怎么写. 有时看到身边的人, 隔阂感莫名而生, 这令我很不安. 三年前的我看到现在的自己, 会唾弃成什么样?</p><p>活成了自己唾弃的模样, 最惨不过如此.</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>过去的三年也绝非暗无天日, 因为身边有着一群有趣的人. 人是社会动物, 不断受到社会环境的影响. 当身边有更优秀的存在时, 会不由自主的学习对方的优点. (能不能习得则是另一回事).</p><p>他们中的许多人是精神榜样. 和有些人交往的时候让我重新思考一些司空见惯的事物. 有些鼓励我重新开始阅读. 有些人教我为人处世的准则. 这三年间的高光时刻, 都离不开他们. 很幸运碰到了你们.</p><h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2><p>现在诉说的这些种种过往, 都是当时的未知. 时隔三年, 现在我又走到了一个更加错综复杂的岔路口.</p><p>兴奋显然掩盖不住对于无限未来的担忧. 我知道我变了. 也或许没有. 可是纵使再有多的不确定性, 未来在到来的那一刻也会告诉我确切的命运安排.</p><p>在畏惧无穷的时候, 低头看看脚下或许是个不错的主意.</p><p>我将独自穿行于无穷.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/The-Graduate/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C语言 | 从内存视角看函数和指针的本质</title>
      <link>https://hisenz.com/post/functions-in-C-and-assambly/</link>
      <guid>https://hisenz.com/post/functions-in-C-and-assambly/</guid>
      <pubDate>Mon, 04 Mar 2019 13:26:29 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;descrription&quot; itemprop=&quot;descrription&quot; content=&quot;海森的博客&quot;&gt;

&lt;p&gt;近期在尝试编写一个&lt;code&gt;Simpson&amp;#39;s Rule&lt;/code&gt;近似数值积分的例子, 忽然想到可以把被积函数作为一个参数传入, 使这个积分函数更具有通用性. 这个例子我们会在文末作为实际应用来阐述. 在开始之前, 我们先要讨论一下C语言里的函数到底和函数调用到底是什么.&lt;/p&gt;
&lt;p&gt;这篇文章篇幅较长, 且涉及较多示例和证明代码, 建议在桌面设备上阅读. 对于证明代码, 请务必亲自动手编译, 只有真正动手敲过的代码才算有深入理解.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="descrription" itemprop="descrription" content="海森的博客"><p>近期在尝试编写一个<code>Simpson&#39;s Rule</code>近似数值积分的例子, 忽然想到可以把被积函数作为一个参数传入, 使这个积分函数更具有通用性. 这个例子我们会在文末作为实际应用来阐述. 在开始之前, 我们先要讨论一下C语言里的函数到底和函数调用到底是什么.</p><p>这篇文章篇幅较长, 且涉及较多示例和证明代码, 建议在桌面设备上阅读. 对于证明代码, 请务必亲自动手编译, 只有真正动手敲过的代码才算有深入理解.</p><a id="more"></a><p>文章的第一节我们从指令和数据的区别出发, 窥见函数与调用的本质. 第二节分析函数在内存里的位置, 理解程序运行时的内存分布. 第三节在前两板块的基础上描述函数的调用和参数传递之细节. 第四节讨论值传参和指针传参, 包括如何将函数作为参数以传递. 第五节是围绕辛普森法积分例程讲解, 综合前文内容作为函数指针的应用演示.</p><h2 id="函数与调用的本质"><a href="#函数与调用的本质" class="headerlink" title="函数与调用的本质"></a>函数与调用的本质</h2><h3 id="数据-vs-指令"><a href="#数据-vs-指令" class="headerlink" title="数据 vs. 指令"></a>数据 vs. 指令</h3><blockquote><p>函数就是一段计算机指令的序列</p></blockquote><p><img src="https://img.vim-cn.com/ab/0ae6b54603d721196f056c3d377a11ca7028e0.png" alt=""></p><p>在<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture" rel="external nofollow noopener noreferrer" target="_blank">冯诺依曼架构</a>中, 数据和指令存放在一起. 因为这种架构只需要一套存储器, 在计算机工业早期实现成本较低, 也演化成了今天的主流方案.</p><p>程序是数据和指令的集合. 程序里预先定义好的常量是数据. 程序要求预留的空间(变量)也是数据. 注意计算机并不能理解数据.</p><p>指令定义了计算机的行为, 指示计算机如何处理数据. 那么与数据同样是比特的指令有什么特殊性? 那就是指令可以控制计算机来达到我们预期的操作; 只有一些特殊的控制字(指令)可以达到这个目的, 而控制字<code>Command Word</code>和底层的电路设计息息相关.</p><p>其次, 在正常情况下, 计算机的控制权不会转交到数据上. 这是因为数据本身并不能控制计算机; 计算机无法理解这些未知的控制字, 就会触发异常.</p><p>由于冯诺依曼架构下数据和指令存放在一起, 如果因为某种”巧合”, 数据恰好也是对计算机而言有意义的控制字, 那么计算机就会认为这些数据是指令. 利用精心构造的数据来改变计算机的行为, 是一种常见的攻击手法, 如<a href="https://en.wikipedia.org/wiki/Buffer_overflow" rel="external nofollow noopener noreferrer" target="_blank">缓冲区溢出</a>的利用. 这个概念下文我们还会简略提到.</p><p>读到这里我们总结一下上文: 计算机可以执行(理解)的是指令. </p><p><strong>函数就是一段计算机指令的序列</strong>, 这段代码的第一条指令的地址也就是函数的入口地址. 要执行一段指令, 只需要让计算机把控制权转交给这个函数. </p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><blockquote><p>调用是把rip指向函数起始地址的行为</p></blockquote><p>我们看一个简单的C语言例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">abs</span>(<span class="number">-1024</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译&amp;反汇编<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --no-builtin 排除掉了内建的函数</span></span><br><span class="line">gcc abs.c -o abs --no-builtin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 反汇编</span></span><br><span class="line">objdump -d abs</span><br></pre></td></tr></table></figure></p><p>以下摘取相关反汇编片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">000000000000061a &lt;abs&gt;:</span><br><span class="line"> 61a:push   %rbp</span><br><span class="line"> 61b:mov    %rsp,%rbp</span><br><span class="line"> 61e:mov    %edi,-0x4(%rbp)  ; pass parameter</span><br><span class="line"> 621:mov    -0x4(%rbp),%eax  ; save it in eax</span><br><span class="line"> 624:cltd                    ; sign-extend</span><br><span class="line"> 625:mov    %edx,%eax        ;</span><br><span class="line"> 627:xor    -0x4(%rbp),%eax  ; tricks</span><br><span class="line"> 62a:sub    %edx,%eax        ; see my previous post</span><br><span class="line"> 62c:pop    %rbp</span><br><span class="line"> 62d:retq   </span><br><span class="line"></span><br><span class="line">000000000000062e &lt;main&gt;:</span><br><span class="line"> 62e:push   %rbp</span><br><span class="line"> 62f:mov    %rsp,%rbp</span><br><span class="line"> 632:mov    $0xfffffc00,%edi ; param -1024</span><br><span class="line"> 637:callq  61a &lt;abs&gt;        ; function call</span><br><span class="line"> 63c:mov    $0x0,%eax        ; return 0</span><br><span class="line"> 641:pop    %rbp             ;</span><br><span class="line"> 642:retq                    ;</span><br></pre></td></tr></table></figure></p><p>注: 汇编代码里关于<code>mov</code>与<code>xor</code>的注解请前往我的<a href="/post/利用越界和溢出-C语言/">这篇博文</a>, 此处不深究.</p><p>这里的<code>rip</code>是<code>Instruction Pointer</code>指令指针寄存器, 一个位于CPU的寄存器, 存储着下一条指令的内存地址. </p><p>从高级语言的层面来看, 执行函数的行为叫做<code>call</code>调用. <strong>调用是把rip指向函数起始地址的行为</strong>. 函数起始地址即函数第一条指令所在的地址. 控制权的所在, 就是<code>rip</code>指向的地址.</p><p>默认情况下, rip会顺次指向下一条指令的内存地址. 如X64下<code>pop</code>和<code>push</code>带上参数<code>%rbp</code>以后长度刚好是1字节. 这种情况下执行完一条指令以后, <code>rip</code>直接加一即可. 在一些架构上每条指令长度不等, <code>rip</code>会根据该指令的长度自动递增. 有一些指令, 如<code>call</code>调用指令和<code>jmp</code>强制跳转指令会修改<code>rip</code>寄存器的值, 以实现循环和条件语句. 前者专门用于函数的调用. </p><p>下面我们单步追踪. 假设将要执行的指令位于<code>0x00000637</code>.</p><h4 id="0x00000637"><a href="#0x00000637" class="headerlink" title="0x00000637"></a>0x00000637</h4><p>例子里我们在<code>main</code>中调用了函数<code>abs</code>. 此时rip指向<code>0x00000637</code>. </p><p>反汇编代码中得知<code>abs</code>函数入口位于内存地址<code>0x0000061a</code>. 因此调用<code>abs</code>的汇编代码为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    0x0000061a</span><br></pre></td></tr></table></figure><p>使用<code>jmp</code>的等价版本. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push    %rip</span><br><span class="line">jmp     0x0000061a</span><br></pre></td></tr></table></figure><p>指令<code>call</code>把当前<code>rip</code>寄存器的值(也就是<code>call</code>的下一条指令地址)先保存在栈上, 然后修改值为跳转的目标地址<code>0x0000061a</code>. 这样计算机的控制权就转跳到了这个地址上的指令, 函数开始执行. <code>jmp</code>指令则不会保存上下文而仅仅直接跳转.</p><p>执行完成后, <code>rip</code>值为<code>0x0000061a</code>, 栈上保存的值为<code>0x0000063c</code>. 换言之, 下一条要被执行的指令是<code>abs</code>里的第一条指令<code>push</code>.</p><p><code>abs</code>函数中间过程我们步过, 直到<code>abs</code>的最后一条指令<code>ret</code>. 此时<code>rip</code>指向<code>0x0000062d</code>的<code>ret</code>指令.</p><h4 id="0x0000062d"><a href="#0x0000062d" class="headerlink" title="0x0000062d"></a>0x0000062d</h4><p>函数调用结束的最后需要使用<code>ret</code>指令来恢复原来的地址. <code>ret</code>指令与<code>call</code>指令配对使用. <code>ret</code>的操作过程刚好相反, 从栈上弹出原先保存的地址并写回<code>rip</code>寄存器. 函数调用至此结束.</p><p>栈上保存的地址为<code>0x0000063c</code>, 弹出到<code>rip</code>.</p><p>此时rip指向<code>0x0000063c</code>, 是main函数里<code>call</code>的下一条指令.</p><h2 id="函数的内存位置"><a href="#函数的内存位置" class="headerlink" title="函数的内存位置"></a>函数的内存位置</h2><p>这一节我们一起动手实操, 探究一下运行时堆栈和函数指令存放的位置. 我们需要写一段程序, 这段程序会在不同的位置创建变量并打印出它们的地址.</p><p>注意, 这里的stack和heap都不是准确的地址. 这是因为<a href="https://blog.csdn.net/a511244213/article/details/44994755" rel="external nofollow noopener noreferrer" target="_blank">main函数并非是真正的程序入口</a>; 在这之前还有一些编译器和链接器附上的初始化或是安全保护(如栈保护)代码. 但是这些地址的相对位置足够说明一些事实了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> initialized_var = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> uninitialized_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> local_var_1;</span><br><span class="line">    <span class="keyword">char</span> local_var_2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack 1\t\t%p\n"</span>, &amp;local_var_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack 2\t\t%p\n"</span>, &amp;local_var_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// argc, argv</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv\t\t%p\n"</span>, argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argc\t\t%p\n"</span>, &amp;argc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack address </span></span><br><span class="line">    show_stack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap address</span></span><br><span class="line">    <span class="keyword">char</span> *heap_addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"heap\t\t%p\n"</span>,heap_addr);</span><br><span class="line">    <span class="built_in">free</span>(heap_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uninitialized varibles</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> uninitialized;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uninitialized\t%p\n"</span>, &amp;uninitialized_var);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialized varibles</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> initialized;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"initialized\t%p\n"</span>, &amp;initialized_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// text segment</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"text\t\t%p\n"</span>, show_stack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">argv0x7ffc1d303928</span><br><span class="line">argc0x7ffc1d30382c</span><br><span class="line">stack 10x7ffc1d30380f</span><br><span class="line">stack 20x7ffc1d30380e</span><br><span class="line">heap0x563138330670</span><br><span class="line">uninitialized0x563138326042</span><br><span class="line">initialized0x563138326041</span><br><span class="line">text0x5631381256da</span><br></pre></td></tr></table></figure></p><p>对照我们的输出和下面的图示, 逐条分析输出. 分析从高地址向低地址进行.<br><img src="https://img.vim-cn.com/ae/1b6f9da809fafa99be9907cbaf2eab4fc027cc.jpg" alt=""></p><ol><li><p>argc &amp; argv</p><p> 这两个变量是主函数的两个参数. argc 是参数个数, argv是参数列表指针, 其中argv[0]指向运行的程序名字符串. 这两个变量是<a href="https://en.wikipedia.org/wiki/Exec_(system_call" rel="external nofollow noopener noreferrer" target="_blank">exec</a>)赋予的. 在图上, 它们位于最高的地址位置.</p></li><li><p>stack 1与stack 2</p><p> 栈是由计算机自动分配和释放的, 这套规则由编译器决定. 具体的机器级表示请阅读下一节.</p><p> 这里为了演示栈的地址增长方向, 我们在show_stack的栈帧上分配了两个局部变量. 还记得局部变量分配在stack栈上吗? 先分配的变量位于高地址, 后分配的位于低地址.</p><p> 栈区的空间相比于堆区来说要小很多.</p></li><li><p>heap</p><p> 用malloc手动分配的内存的空间位于堆上. 堆是从低地址向高地址增长的. 这里并没有演示出来, 有兴趣的读者可以动手试一试, 方法和上面观察stack增长方向一致.</p><p> 图中可以看到, stack和heap是动态区域. 堆起始地址以下的内存是静态空间, 是<a href="https://en.wikipedia.org/wiki/Exec_(system_call" rel="external nofollow noopener noreferrer" target="_blank">exec</a>)根据<a href="https://baike.baidu.com/item/ELF/7120560" rel="external nofollow noopener noreferrer" target="_blank">ELF</a>从外部存储器加载到内存里的一个映像. 关于exec和ELF的一些细节, 以后会再写一篇文章详细讲述.</p></li><li><p>uninitialized</p><p> 这里存放着没有初始化的变量. 也称为bss段. 由exec初始化为零.</p></li><li><p>initialized</p><p> 这里存放代码里初始化的变量.</p><p> 注意, 这里两个变量都是全局变量, declare在所有函数之外, 使用<code>extern</code>引入. 为什么不直接在主函数里声明呢? 其实如果仔细阅读了stack这一段的话, 你会意识到函数内声明的变量都是分配在栈上的. main函数也是函数, 如果在函数内定义变量, 则会默认在栈上分配空间. </p></li><li><p>text</p><p> 文本段, 存放程序代码和字符串常量. 我们打印了函数show_stack的地址(等同于其入口地址).</p><p> 如果稍加思索, 就会发现正常情况下rip指向的范围只会在text段里.</p></li></ol><p>综上所述, 函数的指令存放在text段, 运行时函数会操作栈区和堆区. 现在再回头看看第一节里指令和数据的区别, 是否更加的清晰了呢?</p><h2 id="调用规范和参数传递"><a href="#调用规范和参数传递" class="headerlink" title="调用规范和参数传递"></a>调用规范和参数传递</h2><p>在函数调用的本质里我们详细阐述了函数调用在机器层面的表示. 但是细心的读者会发现我们并没有讨论到函数参数的传递. 这里涉及到了<code>callee</code>被调用函数和<code>caller</code>调用者之间的配合.</p><p>C风格的函数传参会在函数调用前, 首先把参数从右到左(从参数列表里的最后一个开始)入栈. 在函数内使用到参数的时候则以<code>%rbp + offset</code>来表示这个特定的参数. 注意这里是<code>+</code>号, 因为 <strong>栈的地址是从高向低增长的</strong>. </p><p>X86默认所有参数从栈上传递, 而X64则把最后四个大小合适的参数<a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2017#parameter-passing" rel="external nofollow noopener noreferrer" target="_blank">通过寄存器传递</a>, 其余的参数同样通过栈传递. 这是因为X64多了好几个寄存器, 且通过寄存器传参的速度远快于内存. 当然这也就对参数的类型做出了限制: 最大不可以超过8字节(单个通用寄存器的容量). 具体的传参方式规定在<code>Calling Convetion</code>调用规范里. 想要深究的读者, <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2017" rel="external nofollow noopener noreferrer" target="_blank">这里</a>是X64的调用规范.</p><p>刚刚又引入了一个新的寄存器. 准确的说应该是两个:<code>rbp</code>与<code>rsp</code>,分别是<code>Base Pointer</code>栈基指针和<code>Stack Pointer</code>栈顶指针. 顾名思义, <code>rbp</code>始终指向当前栈帧的底部地址,<code>rsp</code>指向顶部地址.</p><p><img src="https://img.vim-cn.com/11/122d5b0b9965577a5213f202609e5277b207a1.gif" alt=""></p><p>按照约定, <code>callee</code>被调用的函数要负责保存和恢复上一级栈帧的基地址. 这就是为什么你在函数的开头结尾总能看到<a href="https://en.wikipedia.org/wiki/Function_prologue" rel="external nofollow noopener noreferrer" target="_blank">这样的代码</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; X64 prologue and epilogue</span><br><span class="line"></span><br><span class="line">push   %rbp</span><br><span class="line">mov    %rsp,%rbp</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pop    %rbp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">; X86 prologue and epilogue</span><br><span class="line"></span><br><span class="line">push   %ebp</span><br><span class="line">mov    %ebp, %esp</span><br><span class="line">sub    %esp, N     </span><br><span class="line">; N Bytes reserved for local varibles</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mov    %esp, %ebp</span><br><span class="line">pop    %ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>通过prologue, 原先的<code>rbp</code>(栈基指针)被保存到栈上, 并把目前的栈顶指针设为栈基指针. 栈底指针更高的地址(加偏移)上保存着参数, 更低的地址(减去偏移)上是预留的局部变量空间.</p><p>Epilogue有终场曲之意, 与开场曲的作用相反, 负责释放使用过的内存(把<code>rsp</code>改回当前<code>rbp</code>),再恢复原先的<code>rbp</code>(前一栈帧的栈基地址).</p><p>Prologue和epilogue之间就是真正的函数功能代码. 调用结束以后, <code>caller</code>调用者需要清除调用前压入栈上的参数.</p><p>说句题外话, 上面的代码可以看出32位和64位平台之间的差别不仅仅是CPU总线位数变宽. 在很多细节上, X64也作出了改进.</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>最初接触到指针的时候, 我被这个名词迷惑了好久. 后来发现可以这么理解:</p><blockquote><p>指针就是内存地址</p></blockquote><p>内存地址是一个类似于<code>size_t</code>的整数, 它的长度等同于机器字长(32位机4字节,64位机8字节), 原因就在于它就是一个内存地址. 试想一下:</p><ul><li>32位机并不能寻址一个64位的地址</li><li>64位机下32位地址不足以表示全部内存空间</li></ul><p>上文我们围绕者函数入口地址讨论了很多. 因为 <strong>指针就是内存地址</strong>, 而这个地址是的内容又是函数, 所以我们可以称函数入口地址为 <strong>函数指针</strong>. 类似的, 如果被指向的内容是一个结构体, 我们就可以称其为结构体指针.</p><h3 id="函数指针-vs-指针函数"><a href="#函数指针-vs-指针函数" class="headerlink" title="函数指针 vs. 指针函数"></a>函数指针 vs. 指针函数</h3><p>“函数””指针”同为名词, 前者修饰后者, 后者才是语义上的重点. 因此: </p><ol><li>函数指针是一个 <strong>指向函数</strong> 的 <strong>指针</strong>.</li><li>指针函数是一个 <strong>返回指针</strong> 的 <strong>函数</strong>.</li></ol><h3 id="值传参-vs-指针传参"><a href="#值传参-vs-指针传参" class="headerlink" title="值传参 vs. 指针传参"></a>值传参 vs. 指针传参</h3><p>C语言默认传参行为是值传递, 具体方式是在栈上创建一个副本. 当传递的数据不是很多, 例如一个整数的时候, 性能表现尚可. 但是这样做存在两个问题:</p><ol><li><p>参数较大(如结构体)时, 涉及到内存读写的复制就会很慢. 当此类函数调用频繁的时候就会出现性能瓶颈.</p></li><li><p>参数不可以被修改. 这是因为函数里对参数的修改实际上作用在了副本上, 原来的值不受影响. (数组除外, 下有解释)</p></li></ol><p>使用指针传参可以解决以上两个问题. </p><ol><li><p>当数据过多时, 我们可以不直接告诉函数所需的数据是什么, 而是告诉函数去哪里寻找这些数据. 这就是用指针传参的思想 - 告诉函数所需数据的内存地址. 由于参数的大小最多只有机器字长, 理论上可通过寄存器来传递, 极大提高速度. </p></li><li><p>由于指针引用的是源数据而不是副本, 所做的更改会被保留. 这就奠定了C用结构体来实现多个返回值的基础. libcurl里有许多这样的例子.</p></li></ol><p>下面两个例程分别演示了这两点. </p><p>第一个例程演示了值传参和指针传参的效率差别<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vector_3D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">(vec v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec force;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        do_nothing(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行时间测试(平均值)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m12.753s</span><br><span class="line">user0m12.727s</span><br><span class="line">sys0m0.012s</span><br></pre></td></tr></table></figure></p><p>修改为指针传参版本的两个函数和测试数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">(vec* v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vec* force = (vec*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vec));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        do_nothing(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m10.002s</span><br><span class="line">user0m9.985s</span><br><span class="line">sys0m0.000s</span><br></pre></td></tr></table></figure><p>对比测试数据可以看到指针传参的速度比值传参更快. 当结构体越来越庞大, 这一优势也会越发明显.</p><p>第二个例子演示了数组的传参方式.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show_arr</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR ADDR IN CALLEE\t%p\n"</span>,arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_arr</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> big_array[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR ADDR IN MAIN\t%p\n"</span>, big_array);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If array were passed as copy, this address shall be different</span></span><br><span class="line">    show_arr(big_array);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This gives zero</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR[0] BEFORE MOD\t%d\n"</span>,big_array[<span class="number">0</span>]);  </span><br><span class="line">    mod_arr(big_array);</span><br><span class="line">    <span class="comment">// if array were passed as copy, a[0] would still be zero.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ARR[0] AFTER MOD\t%d\n"</span>,big_array[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARR ADDR IN MAIN0x7ffd78738200</span><br><span class="line">ARR ADDR IN CALLEE0x7ffd78738200</span><br><span class="line">ARR[0] BEFORE MOD0</span><br><span class="line">ARR[0] AFTER MOD1</span><br></pre></td></tr></table></figure></p><p>首先, 我们在主函数里创建了一个数组并打印其地址. 然后将这个数组作为参数传入<code>show_arr</code>. 该函数答应出其数组参数的地址. </p><p>假设数组是按照值传参的方法传递的话, <code>show_arr</code>打印出来的地址应该是值传参创建的副本, 与主函数里打印出来的结果不一致. 但这并非我们所观察到的现象. 这说明数组是以指针方式传递的. (事实上并不奇怪, 数组名实际上也等价于数组的首地址!) </p><p>其次, <code>mod_arr</code>修改了数组里的内容. 如果数组是值传递, 修改好的副本并不会影响到原来的内容, 也就是说第二次print的内容也该是零. 通过指针传参, 内存里的源数据得以被直接修改. 在实际开发中, 结构体指针更常用于这种情况. 多个返回值通过修改结构体指针指向的内容, 而用函数的返回值(按照惯例是整数)来表示函数是否出现异常.</p><p>有兴趣的读者可以自行证明, 通过值传参后修改其参数并不会影响到源数据. </p><h3 id="通过函数指针调用"><a href="#通过函数指针调用" class="headerlink" title="通过函数指针调用"></a>通过函数指针调用</h3><p>前文提到, <code>rip</code>里存储的就是内存地址. 虽说其他的寄存器也可以存放内存地址, <code>rip</code>里的值却有着特殊意义. <strong>这个内存地址的内容将被视为指令来执行</strong>.</p><p>同样在前面的反汇编代码里, 调用<code>abs</code>函数的时候实际是通过跳转到其第一条指令的地址来实现的. 那么我们是否也可以从函数和函数调用的本质出发来重新审视函数呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,hello);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// conventional call</span></span><br><span class="line">    hello();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func pointer call</span></span><br><span class="line">    <span class="keyword">int</span> (*FUNC) () = hello;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, *FUNC);</span><br><span class="line">    FUNC();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x56552f75468a</span><br><span class="line">Hello!</span><br><span class="line">0x56552f75468a</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure></p><p>这个程序先打印出函数<code>hello</code>的地址, 再分别以普通和函数指针的方式调用一次. 在获取函数指针以后我们打印出来, 和第一句直接用函数名打印出的地址一致. 这再次印证函数名的本质就是函数的入口地址.</p><p>我刚开始接触到函数指针的时候觉得这样调用非常麻烦, 似乎没有什么实际的应用. 不要急, 很快我们就要开始展示函数指针的强大了.</p><h2 id="函数指针应用实例"><a href="#函数指针应用实例" class="headerlink" title="函数指针应用实例"></a>函数指针应用实例</h2><p>最后, 我们回到这篇文章最初的写作动机上. </p><p>这里要实现的是一个尽可能通用的积分函数. 如果要给平方-立方-倒数这三个分别写积分函数, 代码量会大幅增加, 而且这样的写法也不具备通用性: 假设有一天新加了自然对数函数, 则又需要给它写一个专门的积分函数. 但是事实上我们不关心被积函数做了什么, 只要被积函数的返回值即可. </p><p>因此如果把被积函数视作像两个<code>double</code>类型的<code>boundry</code>一样的参数传入, 作为一个通用的函数来调用, 可以大幅简化代码设计.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FUNC)</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, FUNC f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEST FUNCTION LIST</span></span><br><span class="line"><span class="comment">// 1. X^2 - 1,2</span></span><br><span class="line"><span class="comment">// 2. X^3 - 1,2</span></span><br><span class="line"><span class="comment">// 3. 1/X - 1,2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">inverse</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// simpson's rule of integration</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, FUNC f)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (b - a) / <span class="number">6.0</span> * (f(a) + <span class="number">4</span> * f((a + b) / <span class="number">2</span>) + f(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  header</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FUNC\tSTART\tEND\tINTEGRAL\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test table</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SQUARE\t1=\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, square));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CUBE\t1\t2\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, cube));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INVERSE\t1\t2\t%lf\n"</span>, simpson(<span class="number">1</span>, <span class="number">2</span>, inverse));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FUNCSTARTENDINTEGRAL</span><br><span class="line"></span><br><span class="line">SQUARE122.333333</span><br><span class="line">CUBE123.750000</span><br><span class="line">INVERSE120.694444</span><br></pre></td></tr></table></figure></p><p>函数simpson有三个参数:</p><ol><li>积分下边界</li><li>积分上边界</li><li>被积函数</li></ol><p>第三个参数是我们关注的重点. 这里我们就实现了利用函数指针来把一个函数作为参数传递到<code>simpson</code>里. <code>simpson</code>里调用被积函数f的时候, 实际上调用的就是传入的函数指针. 查看<code>simpson</code>函数相关汇编片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">push   %rbp                 ; prologue</span><br><span class="line">mov    %rsp,%rbp            ;</span><br><span class="line">sub    $0x30,%rsp           ;</span><br><span class="line">movsd  %xmm0,-0x8(%rbp)     ; param start</span><br><span class="line">movsd  %xmm1,-0x10(%rbp)    ; param end</span><br><span class="line">mov    %rdi,-0x18(%rbp)     ; param f</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mov    -0x8(%rbp),%rdx      </span><br><span class="line">mov    -0x18(%rbp),%rax     ; func ptr</span><br><span class="line">mov    %rdx,-0x28(%rbp)     </span><br><span class="line">movsd  -0x28(%rbp),%xmm0</span><br><span class="line">callq  *%rax                ; call func</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在调用被积函数前, 函数指针传到<code>rax</code>, 被积函数的参数传到<code>xmm0</code>(浮点寄存器), 然后调用<code>rax</code>里的地址, 即被积函数入口地址.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol start="0"><li>函数就是一段计算机指令的序列</li><li>调用是把rip指向函数起始地址的行为</li><li>函数名 = 函数起始地址</li><li>函数指令位于text段, 运行时数据存放在堆栈</li><li>函数通过栈(X86)或寄存器(x64)传参</li><li>指针就是内存地址</li><li>指针可以高效传参</li><li>函数指针是指向函数的指针</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是自2019中国新年后的第一篇产出. 本以为申请完成后会有很多的空闲时间, 但是因为给自己安排了各种事务, 实际上并不如预想得这么空闲.</p><p>这篇文章最初的写作动机就是在写完simpson积分函数后供自己日后参考的函数指针学习笔记. 不料越写越多, 文章比原来计划的也长了三四倍, 干脆就写成了一篇比较全面的, 给新人指路的文章.</p><p>我最初学C语言是看谭先生的书 - 家里的书柜上也就这么一本. 后来读到<em>The C Programming Language</em>, 相见恨晚. 这本小册子不是面向零基础的读者, 但是对于想要深入了解C语言的程序员十分友好 (毕竟C语言是K&amp;R自己的思想产物). 每个C程序员都该读一读这本手册.</p><p>在这两本书中间我读了<em>Computer System: A Programmer’s Perspective</em>. CMU的大佬操刀编写, 也是该校计算机原理课的教材. 这本书让我系统的接触了汇编语言, 开始熟悉并喜欢上机器级的编程. 后来还有一本<em>自己动手编写操作系统</em>(大概是叫这个名字)给了我上手写汇编和进一步熟悉C语言底层的机会.</p><p>C语言虽说是面向过程的语言, 但目前我的感受, 更恰当的描述是面向机器(或面向内存)的编程语言. 就好像开着手动挡的车的乐趣一样, C语言对机器的操控感是其他高级语言无法比拟的.</p><p>整个现代计算机的体系给我的感觉是”精妙”二字. 无数处精妙的设计让人们从晶体管开始一步一步构建出可以交互的计算机终端. 去年这个时候我在探寻关于<a href="/post/道可道">抽象的力量</a>: 没有了抽象, 拥有无数细节的计算机系统设计将会变得无比繁琐. 一层一层的抽象让人们可以远离底层的细节而专注于创建出更高层的抽象.</p><p>不过有时候回头看看底层的细节, 感受一下字节在电路里的跳动, 也不失为一种乐趣.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/functions-in-C-and-assambly/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | Brainfuck语言解释器</title>
      <link>https://hisenz.com/post/bf-challenge/</link>
      <guid>https://hisenz.com/post/bf-challenge/</guid>
      <pubDate>Sat, 16 Feb 2019 09:22:51 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;挑战 | Brainfuck语言解释器&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;++++++++++ [&amp;gt;+++++++ &amp;gt;++++++++++ &amp;gt;+++&amp;gt;+&amp;lt;&amp;lt;&amp;lt;&amp;lt;-]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;++.&amp;gt;+.+++++++ ..+++.&amp;gt;++.&amp;lt;&amp;lt;+++++++++++++++ .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;.+++.------ .-------- .&amp;gt;+.&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;BF的工作原理模拟了一台简单的图灵机&lt;code&gt;Turing Machine&lt;/code&gt;. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务. &lt;/p&gt;
&lt;p&gt;虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论&lt;code&gt;Computation Theory&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在这个挑战里, 你需要编写一个解释器来运行BF语言.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="挑战 | Brainfuck语言解释器"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>1993年被提出的Brainfuck(以下简称BF)是一种极小化的语言, 全部使用的符号只有八种. 下面是BF的例程Hello World.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p>BF的工作原理模拟了一台简单的图灵机<code>Turing Machine</code>. 这个在1936年由图灵提出的计算模型描述了在一条无限长的纸带上, 机器的读写头不停的移动或读写以完成计算任务. </p><p>虽然图灵模型看上去简单, 但是图灵机可以解决大多数计算问题. 今天常用的计算机正是按照图灵机模型设计的. 因此, 理解了BF的工作原理, 也就很大程度上理解了现代计算机的数学原理和一些简单的计算理论<code>Computation Theory</code>.</p><p>在这个挑战里, 你需要编写一个解释器来运行BF语言.</p><a id="more"></a><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++ [&gt;+++++++ &gt;++++++++++ &gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++ ..+++.&gt;++.&lt;&lt;+++++++++++++++ .</span><br><span class="line">&gt;.+++.------ .-------- .&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++</span><br><span class="line">&gt;+&gt;&gt;&gt;&gt;++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">&gt;++++++++++++++++++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;[&gt;[&gt;&gt;&gt;&gt;&gt;&gt;+&gt;</span><br><span class="line">+&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;[&gt;++++++++++[-</span><br><span class="line">&lt;-[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]&gt;[&lt;&lt;[&gt;&gt;&gt;+&lt;&lt;&lt;</span><br><span class="line">-]&gt;&gt;[-]]&lt;&lt;]&gt;&gt;&gt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]+&lt;[&gt;[-]&lt;[-]]</span><br><span class="line">&gt;[&lt;&lt;+&gt;&gt;[-]]&lt;&lt;&lt;&lt;&lt;&lt;&lt;]&gt;&gt;&gt;&gt;&gt;[+++++++++++++++++++++++++</span><br><span class="line">+++++++++++++++++++++++.[-]]++++++++++&lt;[-&gt;-&lt;]&gt;++++</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;+&gt;+&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;-]&lt;-[&gt;&gt;.&gt;.&lt;&lt;&lt;</span><br><span class="line">[-]]&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]&lt;&lt;[&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</span><br></pre></td></tr></table></figure><h3 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a><strong>完成度</strong></h3><p>本挑战的完成度分为三个等级</p><ol><li>可以解析<code>+</code>,<code>-</code>,<code>&lt;</code>,<code>&gt;</code>四种操作</li><li>可以解析<code>.</code>,<code>,</code>两种操作</li><li>可以解析循环</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>学习图灵计算模型</li><li>学习ASCII编码</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li><li>理解编程语言的本质</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%211344&authkey=APVSI6GDKYRggf0" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基百科: <ul><li><code>brainfuck.pdf</code></li><li><code>turing_machine.pdf</code></li><li><code>ascii.pdf</code></li></ul></li><li>视频 &amp; 英语字幕: <ul><li><code>How Brainfuck Work.mp4</code> </li><li><code>How Brainfuck Works.ass</code></li></ul></li><li>在线 Brainfuck Visualizer<ul><li><a href="https://fatiherikli.github.io/brainfuck-visualizer/" rel="external nofollow noopener noreferrer" target="_blank">https://fatiherikli.github.io/brainfuck-visualizer/</a></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/bf-challenge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>随想 | 晨间爵士</title>
      <link>https://hisenz.com/post/jazz-in-morning/</link>
      <guid>https://hisenz.com/post/jazz-in-morning/</guid>
      <pubDate>Mon, 04 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;海森的博客 | 晨间爵士&quot;&gt;

&lt;p&gt;并非所有爵士都属于黑夜. 在晨间迷雾里, 它美的令人窒息. &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="海森的博客 | 晨间爵士"><p>并非所有爵士都属于黑夜. 在晨间迷雾里, 它美的令人窒息. </p><a id="more"></a><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    fixed: true,    autoplay: true,    audio: [        {            name: 'Misty',            artist: 'Ella Fitzgerald',            url:'https://img.vim-cn.com/20/672013f6521c03f281fd018434c85538363cce.mp2',            cover: 'http://p2.music.126.net/_Wfc8snZxj8Wa4dxt9FLWA==/18280480323977240.jpg?param=130y130'        },        {            name: 'I Loves You Porgy',            artist: 'Keith Jarrett',            url:'https://img.vim-cn.com/21/bb7f0aa62889d6076cf2e69718882ec4f6b394.mp2',            cover: 'https://img.vim-cn.com/be/9fbd144b5e22b2e1b0fada97036b4f7f5af788.jpg'        },        {            name: 'Paris Blues',            artist: 'Terry Callier',            url:'https://img.vim-cn.com/88/6bfd1796f1071dec7499f9b3ac3de2753819f2.mp2',            cover: '//y.gtimg.cn/music/photo_new/T002R300x300M0000010wTyL3QoWLQ.jpg?max_age=2592000'        }    ]});</script><h2 id="Misty"><a href="#Misty" class="headerlink" title="Misty"></a>Misty</h2><p>可以横跨三个八度音阶的她, 音准与节奏无可挑剔. “高如黃鶯出谷，低如湖水沈靜”</p><p>百年前降临人间的 Ella Fitzgerald 歌声是有魔力的. 人们说, 即便是同一首歌, 在不同的场合时间下聆听, 她的演绎也不尽相同. </p><blockquote><p>Walk my way,<br>And a thousand violins begin to play,<br>Or it might be the sound of your hello,<br>That music I hear,<br>I get misty, the moment you’re near.</p></blockquote><p>简单清澈的钢琴伴奏与她的歌声, 晨间听来如此干净, 夜晚却传递出一丝忧伤.</p><p>清晨听, 舒缓安抚的声音带来宁静, 仿佛撑着小船穿梭于水面上的薄雾.<br>黑夜听, 忧郁沧桑, 有如一位老妇人平静讲述她传奇的一生.</p><p>故有诗云</p><blockquote><p>夜深忽梦少年事<br>唯梦闲人不梦君</p></blockquote><h2 id="I-Loves-You-Porgy"><a href="#I-Loves-You-Porgy" class="headerlink" title="I Loves You Porgy"></a>I Loves You Porgy</h2><p>一首写在水上的诗, 钢琴表现的轻盈且宁静.</p><blockquote><p>Bess: I loves you, Progy.<br>Porgy: Bess, you is my women now.</p></blockquote><p>本曲出自音乐剧 Progy and Bess. 剧中, 生活在社会底层的两人并没有受过教育, 因此语法糟糕. 听说这部音乐剧评价不错, 我已经安排上观赏日程.</p><h2 id="Paris-Blues"><a href="#Paris-Blues" class="headerlink" title="Paris Blues"></a>Paris Blues</h2><p>个人非常喜爱的一首爵士. 我的<a href="/about">About页面</a>里也嵌入了这首歌. 在迷茫和忧郁的早晨, 隔着咖啡杯上氤氲雾气望向白茫茫的窗外, 是 Paris Blues 带给我的感觉.</p><blockquote><p>She’s out of my mind<br>I’m out of my head</p></blockquote><p>Terry Callier 的嗓音有厚度有沧桑, 和 Louis Armstrong 有几分内在的相像. 可惜当我知道这首爵士的时候, 他已经去天堂唱歌了.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/jazz-in-morning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>榜单 | 海森的2018年度歌单</title>
      <link>https://hisenz.com/post/2018-top-10/</link>
      <guid>https://hisenz.com/post/2018-top-10/</guid>
      <pubDate>Sat, 02 Feb 2019 11:53:42 GMT</pubDate>
      <description>
      
        
        
          &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;榜单 | 海森的2018年度歌单&quot;&gt;


&lt;p&gt;这里是海森2018年的TOP10歌单. 其中一些作品非常值得我在日后细细撰写乐评.&lt;/p&gt;
&lt;p&gt;&lt;link rel=
        
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="榜单 | 海森的2018年度歌单"><p>这里是海森2018年的TOP10歌单. 其中一些作品非常值得我在日后细细撰写乐评.</p><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [        {            name: 'Misty',            artist: 'Ella Fitzgerald',            url:'https://img.vim-cn.com/20/672013f6521c03f281fd018434c85538363cce.mp2',            cover: 'http://p2.music.126.net/_Wfc8snZxj8Wa4dxt9FLWA==/18280480323977240.jpg?param=130y130'        },        {            name: 'Fly Me To The Moon',            artist: 'Elsee',            url:'https://img.vim-cn.com/8c/803d9a1d44200cc09bb6606cfea1182fc9d857.mp2',            cover: 'http://p1.music.126.net/FcGeALZpuINYBne94kUNow==/109951162827593690.jpg?param=130y130'        },        {            name: '1900\'s Madness #2',            artist: 'Ennio Morricone / Amedeo Tommasi',            url:'https://img.vim-cn.com/ae/6f51083bdaa6206a79564f9d71c4ed5440582e.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        },        {            name: '宠爱爵钢版 (Chong Love)',            artist: 'MT1990',            url:'https://img.vim-cn.com/d0/caf6f61778d90c5fb07652db94983f5ffcf7bb.mp2',            cover: 'http://p2.music.126.net/bXkY80qkoLUE7klHTStnjw==/109951162971988949.jpg?param=130y130'        },        {            name: 'Besame Mucho',            artist: 'Lex Vandyke',            url:'https://img.vim-cn.com/86/0e794d5efc880afc38d9d5007d209c07a9ac4c.mp2',            cover: 'https://img.vim-cn.com/b1/3295e1f26e42c39f45adb28eded47690dbdb7e.png'        },        {            name: 'Life Is A Circle',            artist: 'Michale Whalen',            url:'https://img.vim-cn.com/77/4a9e4cab1657ecdbea6d993629ee304d45ab86.mp2',            cover: 'https://img.vim-cn.com/86/d473f1756c0288087425f1782309c00109b4f3.png'        },        {            name: 'Yumeji\'s Theme',            artist: '梅林茂',            url:'https://img.vim-cn.com/4b/3a25010a6e6f1d34ccbc9856efda440a94ea1f.mp2',            cover: 'http://p1.music.126.net/HpKxdM5MWsIqfo-i6RmpdA==/109951163298362339.jpg?param=130y130'        },        {            name: 'Love Theme (天堂电影院)',            artist: 'Henry Mancini',            url:'https://img.vim-cn.com/fa/a83a027dc4ad55d8eef3aaf53fedd78db4f301.mp2',            cover: 'https://img.vim-cn.com/b1/db197519c971ad2faff1bc68b751bc08b81d45.png'        },        {            name: 'Magic Waltz',            artist: 'Amedeo Tommasi',            url:'https://img.vim-cn.com/ac/d77fc506f520de6bfce84bcf7bac6d560240ba.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        },        {            name: 'The Crave',            artist: 'Ennio Morricone',            url:'https://img.vim-cn.com/53/cd0ef355febaf131721e7d01a052ee556a0931.mp2',            cover: 'https://img.vim-cn.com/12/6ec0838e8b28d27b714b2d29ea8a47e6446ded.jpg'        }    ]});</script>]]></content:encoded>
      
      <comments>https://hisenz.com/post/2018-top-10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>意境 | 末日</title>
      <link>https://hisenz.com/post/alone-in-the-desert/</link>
      <guid>https://hisenz.com/post/alone-in-the-desert/</guid>
      <pubDate>Sat, 02 Feb 2019 05:45:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;现在车抛锚了, 我只能缩在吉普车里. 即便此刻是正午, 蔽天浓烟之下四周依然昏暗.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>现在车抛锚了, 我只能缩在吉普车里. 即便此刻是正午, 蔽天浓烟之下四周依然昏暗.</p><a id="more"></a><p>公路两边, 是无边无际的漫漫黄沙与鬼斧神工的岩石.</p><p>电力通讯网瘫痪, 手机成了废品, 我现在仍然把它放在口袋里也只是”出于情怀”. 唯有自由的电波在空气中毫无痕迹的通过, 此刻这也是与外界通信的唯一方式.</p><p>转动车载电台上的旋钮时候, 除了通联, 偶尔还能收听到一些音乐电台. 这成了逃亡之路上唯一的消遣. 模糊记得, 昨天在加油站修整的时候似乎还能收到七八个台, 今天却只听到两个Classic和R&amp;B. 从其它幸存者的闲聊那里听说, 位于感染区的音乐电台似乎都无人值守维护, 难保设备不出点什么小毛病, 因此戏称”废土电台”. 而我只希望在到达尚未感染的北极圈之前(至少在目前来看还是伊甸园), 一路上还能有音乐陪伴.</p><p>调回到最先发现的音乐台, 方才从调谐钮上移开了手. 我放倒座椅躺下, 盯着触手可及的车顶, 盘算着下一步的行动. 车就是性命. 车(还能工作的车)才能载我到我想去或是我不得不去的地方.</p><p>但是, 就算我可以到达安全区, 在那里汇集的幸存者都会是些什么人呢? “像我这样的亡命之徒吧,”我自嘲道. 比起日益恶化生存条件, 人才是最大的威胁. 因此大多数时候我只是保持着沉默, 仅仅收听其他幸存者的通联而一言不发. 于我而言, 荒无人烟的沙漠才是最安全的地方: 视野开阔, 开车逃跑也容易. 一切都好, 除了食物弹药和汽油奇缺. </p><p>我直起身, 从手套箱里摸出地图. 现在驶离Las Vegas已有30英里, 只要沿着15号公路一路向北, 汽油供应不会有问题. 我只能暗自祈祷先行的逃亡者还有点良心, 这样沿途的废弃加油站里很大概率可以找到汽油和一些工具. 桶装的油是首选, 拎上就可以往车里灌; 废弃的车里也可以偷出一些油, 不过一辆一地拿着虹吸管去挺麻烦, 况且汽油的味道实在不怎么样. </p><p>想到这里, 我顺手拆了一包小甜饼. 几天之前与感染者一场血战之后, 我从超市里搜刮来的水和食物够支持我两个星期, 所以到达目的地前我每天都可以胡吃海喝, 前提是我吃不腻这种草莓果酱小曲奇.</p><p>只要我可以修好我的车.</p><p>不管怎么说, 在这里抛锚的我孤立无援. 没有人可以来帮助我. 走出这里只能依赖自己的勇气, 知识和希望. 一口白兰地下肚, 我把音量调小了些, 披上外套, 伸手去拉开车门.</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/alone-in-the-desert/#disqus_thread</comments>
    </item>
    
    <item>
      <title>挑战 | 逆波兰表达式解释器</title>
      <link>https://hisenz.com/post/rpn-challenge/</link>
      <guid>https://hisenz.com/post/rpn-challenge/</guid>
      <pubDate>Sat, 02 Feb 2019 04:50:41 GMT</pubDate>
      <description>
      
        &lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;挑战 | 逆波兰表达式解释器&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;Copyright 2019 &lt;a href=&quot;mailto:hisen@hisenz.com&quot;&gt;HisenZhang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1920年, 逆波兰表示法&lt;code&gt;Reverse Polish Notation&lt;/code&gt;首次被提出. 不同于我们常用的中置表达式, 逆波兰表示法将操作符写在操作数后面, 例如阶乘&lt;code&gt;!&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;逆波兰表示法的这一特性适合使用栈&lt;code&gt;stack&lt;/code&gt;来解析. 这种设计可以减少存储器访问. 因此在1960和1970年代, 逆波兰记法广泛应用于台式和手持计算器.&lt;/p&gt;
&lt;p&gt;在这个挑战里, 你需要编写一个解释器来计算逆波兰表达式, 实现加减乘除四则运算.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<meta name="description" itemprop="description" content="挑战 | 逆波兰表达式解释器"><blockquote><p>Copyright 2019 <a href="mailto:hisen@hisenz.com">HisenZhang</a></p></blockquote><p>1920年, 逆波兰表示法<code>Reverse Polish Notation</code>首次被提出. 不同于我们常用的中置表达式, 逆波兰表示法将操作符写在操作数后面, 例如阶乘<code>!</code>. </p><p>逆波兰表示法的这一特性适合使用栈<code>stack</code>来解析. 这种设计可以减少存储器访问. 因此在1960和1970年代, 逆波兰记法广泛应用于台式和手持计算器.</p><p>在这个挑战里, 你需要编写一个解释器来计算逆波兰表达式, 实现加减乘除四则运算.</p><a id="more"></a><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>输入样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 7 8 + *</span><br></pre></td></tr></table></figure><p><strong>输出样例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure><p><strong>输入样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2 3 * 4 +</span><br></pre></td></tr></table></figure><p><strong>输出样例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.6</span><br></pre></td></tr></table></figure><h3 id="完成度"><a href="#完成度" class="headerlink" title="完成度"></a><strong>完成度</strong></h3><p>本挑战的完成度分为两个等级</p><ol><li>可以解析个位数的操作数</li><li>可以解析多位操作数(包括浮点数)</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>学习栈<code>stack</code>结构与栈的操作</li><li>强化列表与字符串的操作</li><li>强化四则运算的编程</li><li>强化条件/循环语句</li></ol><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>访问OneDrive以获取相关材料</p><iframe src="https://onedrive.live.com/embed?cid=8CBB3C51F3734709&resid=8CBB3C51F3734709%211334&authkey=AGFW-CkDnflM7fw" width="165" height="128" frameborder="0" scrolling="no"></iframe><ol><li>中文维基百科: <ul><li><code>reverse_polish_notation.pdf</code></li></ul></li><li>视频 &amp; 英语字幕: <ul><li><code>Reverse Polish Notation and The Stack - Computerphile.m4v</code> </li><li><code>Reverse Polish Notation and The Stack - Computerphile.ass</code></li></ul></li><li>从零开始学Python(第二版)节选<ul><li><code>list_functions.pdf</code></li></ul></li></ol><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol><li>列表对象有两个方法: <ul><li><code>append()</code></li><li><code>pop()</code></li></ul></li><li>字符串对象有个方法:<ul><li><code>strip()</code></li></ul></li></ol>]]></content:encoded>
      
      <comments>https://hisenz.com/post/rpn-challenge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iFixit: 自己动手维修</title>
      <link>https://hisenz.com/post/ifixit/</link>
      <guid>https://hisenz.com/post/ifixit/</guid>
      <pubDate>Tue, 15 Jan 2019 11:00:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;以下内容翻译自&lt;a href=&quot;https://ifixit.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;iFixit&lt;/a&gt;主页.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>以下内容翻译自<a href="https://ifixit.org/" rel="external nofollow noopener noreferrer" target="_blank">iFixit</a>主页.</p><a id="more"></a><h2 id="为什么选择维修"><a href="#为什么选择维修" class="headerlink" title="为什么选择维修"></a>为什么选择维修</h2><ul><li>省钱</li><li>拯救环境</li><li>更好的掌控自己的设备</li><li>拒绝”一次性经济”</li><li>加入维修运动!</li></ul><h2 id="维修就是自由"><a href="#维修就是自由" class="headerlink" title="维修就是自由"></a>维修就是自由</h2><p>当你购买了设备, 你应当做它的主人. 无论何时何地, 你有权按照你的想法使用它, 更改它, 修复它. 捍卫维修的权利: 这是我们应得的.</p><h2 id="维修创造就业"><a href="#维修创造就业" class="headerlink" title="维修创造就业"></a>维修创造就业</h2><p>尽可能的去维修产品: 翻新过的手机可以出售给其他人; 修复的计算机可以减小人类间的数字鸿沟. 维修工作可以在当地进行.</p><h2 id="维修持续发展"><a href="#维修持续发展" class="headerlink" title="维修持续发展"></a>维修持续发展</h2><p>从前的产品可以使用很久, 而现在的大多只有数年寿命. 维修是环保的. 它使得你爱的产品继续工作而不是被丢弃.</p><h2 id="自己动手修复"><a href="#自己动手修复" class="headerlink" title="自己动手修复"></a>自己动手修复</h2><p>每个人都有维修的需要. 一些人用不上清洁的水是因为他们不知道如何维修水泵. 许多的公司没有向那些独立的维修专家提供可用的零件和手册. 我们尝试改变这一局面.</p><p>iFixit 是一套免费的维修手册. 我们会教你如何维修你的设备. </p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/ifixit/#disqus_thread</comments>
    </item>
    
    <item>
      <title>料理 | 关于舒肥</title>
      <link>https://hisenz.com/post/Sous-Vide/</link>
      <guid>https://hisenz.com/post/Sous-Vide/</guid>
      <pubDate>Sun, 30 Dec 2018 10:46:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;舒肥法&lt;code&gt;Sous Vide&lt;/code&gt;是一种将食材真空低温加热的处理方法. 利用舒肥法可以做出鲜嫩多汁的料理, 把常见的食材潜力尽数发挥. 由于可以把加热过程交给机器控制而无需人工插手, 适合新手以及懒人. &lt;/p&gt;
&lt;p&gt;这篇文章介绍了舒肥法基本要点, 一种低成本DIY舒肥机的方法以及鸡胸肉, 鸡蛋和牛肉的舒肥法烹调示例.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>舒肥法<code>Sous Vide</code>是一种将食材真空低温加热的处理方法. 利用舒肥法可以做出鲜嫩多汁的料理, 把常见的食材潜力尽数发挥. 由于可以把加热过程交给机器控制而无需人工插手, 适合新手以及懒人. </p><p>这篇文章介绍了舒肥法基本要点, 一种低成本DIY舒肥机的方法以及鸡胸肉, 鸡蛋和牛肉的舒肥法烹调示例.</p><a id="more"></a><p><img src="https://s1.ax1x.com/2018/12/30/FhVrpF.jpg" alt="chicken_breast_wide.jpg"></p><h2 id="舒肥-时间的魔法"><a href="#舒肥-时间的魔法" class="headerlink" title="舒肥: 时间的魔法"></a>舒肥: 时间的魔法</h2><p>利用舒肥法可以做出鲜嫩多汁的料理, 把常见的食材潜力尽数发挥. 由于可以把加热过程交给机器控制而无需人工插手, 适合新手以及懒人.</p><p>基本的舒肥方式是保持水温恒定, 食材放入塑料袋抽成真空, 在水里慢慢的低温加热. 事实上只要能近似满足这些条件, 也可以做出相当不错的效果. </p><p>由于舒肥是定温烹调法, 所以不会出现烹调过头的情况. 那么质感的控制由两个变量共同决定: 温度和时间. 我自己总结的经验是:　温度决定食材的熟度, 而时间决定嫩度.</p><ol><li><p>温度<br>我认为温度是一个更重要的变量. 别小看一摄氏度的温差. 哪怕只是一摄氏度的温差都会导致最后食材的熟度差异. 以<a href="https://www.gq.com.tw/mobile/blog/cookingpaul/detail-1783.html" rel="external nofollow noopener noreferrer" target="_blank">舒肥蛋的例子</a>作参考, 61-63摄氏度对应的是不同性状的蛋.</p><blockquote><p>熟度的本质是食物的核心温度. </p></blockquote></li><li><p>时间<br><img src="https://s1.ax1x.com/2018/12/30/FhlXAH.png" alt="curve.png"><br>在温度-时间曲线收敛于设定温度的时候, 食材就基本熟了. 此时时间的重要性凸显了出来. 在煮熟的基础上, 时间越长, 析出的汁水也会越多, 食物也就会变得更加入味, 但不那么嫩.</p></li></ol><h2 id="自制设备"><a href="#自制设备" class="headerlink" title="自制设备"></a>自制设备</h2><p>市售舒肥机售价大致在400人民币起步. 我个人的猜测是因为舒肥法在内地听说过的人不多, 市场也不大, 国内很少有厂家生产. 于是就自然而然的想到可以自制一套舒肥机. 说一句题外话, 我在查找舒肥的中文资料的时候, 大多也都是从台湾的博客/网站上习得的. 台湾在先锋餐饮文学方面的繁荣远超内地.</p><h3 id="电路组成"><a href="#电路组成" class="headerlink" title="电路组成"></a>电路组成</h3><p>最初的设想是用Arduino重新造一个轮子出来. 实现起来并不困难, 但是在核算成本的时候发现温度检测模块的价格并不低廉. 于是直接购入一个温控电源. 这个温控电源有自己的防水温度探头. 当温度低于阀值的时候通导, 加热到另一个温度后断开. </p><p><img src="https://s1.ax1x.com/2018/12/30/Fht3VK.jpg" alt="switch.jpg"></p><p>加热器件采用了600W的电热管. 电热管的作用是维持温度, 因此加热功率不需要很大, 保温足矣.</p><p><img src="https://s1.ax1x.com/2018/12/30/Fhtlb6.jpg" alt="heater.jpg"></p><p>另外据悉市面上的米家电磁炉也有舒肥功能, 售价在300左右. 但是我没有使用过, 不作评价.</p><h3 id="成本核算"><a href="#成本核算" class="headerlink" title="成本核算"></a>成本核算</h3><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">数量</th><th style="text-align:center">价格/人民币</th></tr></thead><tbody><tr><td style="text-align:center">温控电源</td><td style="text-align:center">1</td><td style="text-align:center">29.9</td></tr><tr><td style="text-align:center">电热管</td><td style="text-align:center">1</td><td style="text-align:center">9.8</td></tr><tr><td style="text-align:center">总计</td><td style="text-align:center"></td><td style="text-align:center">37.7</td></tr></tbody></table><h3 id="组合与使用"><a href="#组合与使用" class="headerlink" title="组合与使用"></a>组合与使用</h3><h4 id="装置如图"><a href="#装置如图" class="headerlink" title="装置如图"></a>装置如图</h4><p><img src="https://s1.ax1x.com/2018/12/30/FhlLHe.jpg" alt="equipment.jpg"></p><p>左侧电热管连接至温控电源. 右上角黑色细线是温控电源的探头. </p><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol><li>电热管需要全部浸没在水中. </li><li>电热管工作中请勿触碰.</li><li>工作时电热管间歇通电, 频繁开关是正常现象.</li><li>可以把容器放在保温的箱子里, 盖上盖子以减少热量散失. 这样可以节省能源并减小温度波动.</li><li>温度阀值的设置<br>由于电热管即使断电仍然有余温, 会导致温度的继续上升, 超过食谱规定的温度. 经过实验, 我会把启动温度设定在菜谱温度<code>-0.6</code>摄氏度, 停止温度设定在<code>-0.3</code>摄氏度. 这样可以把温度控制在食谱指定的温度左右.</li><li>放入食材前可以加入热水使温度高于菜谱温度<code>3</code>-<code>4</code>摄氏度.这是应为</li><li>温度探头尽可能贴近食物以测得食物本身的温度.</li><li>舒肥的时间和温度参考请参考文末我收集到的一些表格.</li></ol><h2 id="舒肥鸡胸肉"><a href="#舒肥鸡胸肉" class="headerlink" title="舒肥鸡胸肉"></a>舒肥鸡胸肉</h2><p><img src="https://s1.ax1x.com/2018/12/30/FhVgmR.jpg" alt="chicken_breast_square.jpg"></p><blockquote><p>舒肥鸡胸肉 @ 64摄氏度, 40分钟</p></blockquote><p>用舒肥法处理的鸡胸肉异常嫩且多汁, 没有传统方式烹调过度产生的木渣口感(我觉得柴掉的鸡胸肉就该这么形容).</p><table><thead><tr><th style="text-align:center">食材</th><th style="text-align:center">数量</th><th style="text-align:center">市价/人民币</th></tr></thead><tbody><tr><td style="text-align:center">鸡胸肉</td><td style="text-align:center">500克</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">海盐</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">现磨黑胡椒</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">橄榄油</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">百里香(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">欧芹(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr></tbody></table><p>一整块鸡胸肉, 两面加盐和现磨黑胡椒. 一定不要吝啬, 最好是粗颗粒的海盐. 黑胡椒必须是现磨, 预磨好的颗粒是没有灵魂的! (预研磨的黑胡椒香气不足)</p><p>加入一些Thyme! 有新鲜的百里香最好, 没有的话也可以用干的来替代. 接下来把调理好的鸡胸肉装入塑料袋(保鲜袋或者是专业的袋子), 并加入一些橄榄油以保持嫩的口感. 将袋子浸入冷水中排出空气, 夹住防止漏气.</p><p>装置预热到64摄氏度. 放入舒肥袋, 浸没全部食材. 如果担心滑落可以用夹子夹在容器边上. 确保温度探头尽可能的贴近食物. 启动计时器, 等待40分钟.</p><p>计时停止时取出舒肥袋. 此时鸡胸肉已经可以食用, 切片并浇上舒肥过程中析出的肉汁. 这是个人更偏爱的食用方式.</p><p>如果喜欢烟熏的味道, 可以油煎带来<a href="https://zh.wikipedia.org/zh-hans/%E7%BE%8E%E6%8B%89%E5%BE%B7%E5%8F%8D%E5%BA%94" rel="external nofollow noopener noreferrer" target="_blank">美拉德反应</a>. 加热铸铁锅至高温, 加入橄榄油并放入鸡胸肉. 保持一段时间再翻面, 表面会有漂亮的褐色纹理.</p><p>鸡胸肉通常会作为主菜<code>main course</code>出现, 和土豆泥搭配. 土豆泥的制作又是另一门学问, 如果为了节省时间只能从土豆泥粉调制. 佐餐饮品可以搭配一些口感清淡的酒.</p><h2 id="舒肥蛋"><a href="#舒肥蛋" class="headerlink" title="舒肥蛋"></a>舒肥蛋</h2><p><img src="https://s1.ax1x.com/2018/12/30/FhVsl4.jpg" alt="egg_60.jpg"></p><blockquote><p>舒肥蛋 @ 63摄氏度,一小时</p></blockquote><table><thead><tr><th style="text-align:center">食材</th><th style="text-align:center">数量</th><th style="text-align:center">市价/人民币</th></tr></thead><tbody><tr><td style="text-align:center">鸡蛋</td><td style="text-align:center">1个</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">日式酱油</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">欧芹(可选)</td><td style="text-align:center">适量</td><td style="text-align:center">N/A</td></tr></tbody></table><p>相对来说舒肥蛋的制作是最简单的. 常温鸡蛋可以直接放入装置中舒肥, 但是因为鸡蛋可能会与电热管直接接触, 我还是推荐用塑料袋排掉气体再放入设备.</p><p><img src="https://s1.ax1x.com/2018/12/30/FhVy6J.jpg" alt="egg_soy.jpg"></p><blockquote><p>舒肥蛋 @ 63摄氏度,一小时</p></blockquote><p>我个人偏好63摄氏度加热1个小时的口感. 直接打在小碟里, 配上一些日式酱油. 蛋黄浓稠, 口感厚重的像芝士, 蛋白软嫰入口即化. 也可以把加热完成的鸡蛋在冷水里放置一会, 鸡蛋入口时的温度会更加适宜.</p><p><img src="https://s1.ax1x.com/2018/12/30/Fh3Uij.md.jpg" alt="egg_60.jpg"></p><blockquote><p>舒肥蛋 @ 63摄氏度,一个半小时</p></blockquote><p>这一组条件下产生的鸡蛋更像是温泉蛋, 蛋白看上去凝固程度更高一些. 更长的舒肥时间会给鸡蛋带来更厚重的口感.</p><h2 id="牛肉"><a href="#牛肉" class="headerlink" title="牛肉"></a>牛肉</h2><p><img src="https://s1.ax1x.com/2018/12/30/Fh60LF.jpg" alt="sous_vide_beef.jpg"></p><blockquote><p>舒肥牛上脑 @ 58摄氏度,40分钟</p></blockquote><p>牛肉的烹调也是一门大学问, 有机会的话单独写一篇文章来分析. 牛肉的处理同鸡胸肉大致相同, 但是我强烈建议最后下锅引发美拉德反应: 这一步可以给牛排注入灵魂!</p><p>传统方式在对付厚度3厘米以下的牛排时表现还不错, 但是面对更厚的牛排就无能为力了, 往往是两面<code>well done</code>而核心<code>rare</code>. 舒肥法在这种情况下的表现极佳, 可以做到内里的熟度一致.</p><p>下面这张图是传统方式制作的牛排:</p><p><img src="https://s1.ax1x.com/2018/12/30/Fh6wsU.jpg" alt="traditional_beef.jpg"></p><blockquote><p>传统方式制作的牛上脑</p></blockquote><p>对比一下可以发现舒肥法制作的牛肉纤维更细致, 汁水更加的丰富, 口感明显更嫩.</p><h2 id="温度时间表"><a href="#温度时间表" class="headerlink" title="温度时间表"></a>温度时间表</h2><p>以下内容收集自网络</p><h3 id="牛肉-1"><a href="#牛肉-1" class="headerlink" title="牛肉"></a>牛肉</h3><p><img src="https://www.cook72.com/wp-content/uploads/2018/06/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-08-06-%E4%B8%8B%E5%8D%885.42.13.png" alt="beef_data"></p><h3 id="禽类"><a href="#禽类" class="headerlink" title="禽类"></a>禽类</h3><p><img src="https://www.cook72.com/wp-content/uploads/2018/05/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-07-%E4%B8%8B%E5%8D%883.08.49.png" alt=""></p><p><img src="https://www.cook72.com/wp-content/uploads/2018/05/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-07-%E4%B8%8B%E5%8D%883.09.06.png" alt=""></p><h3 id="海鲜"><a href="#海鲜" class="headerlink" title="海鲜"></a>海鲜</h3><p><img src="https://www.cook72.com/wp-content/uploads/2018/05/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2018-05-08-%E4%B8%8A%E5%8D%8810.38.25-1.png" alt=""></p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/Sous-Vide/#disqus_thread</comments>
    </item>
    
    <item>
      <title>这一年: 2018</title>
      <link>https://hisenz.com/post/2018-summary/</link>
      <guid>https://hisenz.com/post/2018-summary/</guid>
      <pubDate>Mon, 24 Dec 2018 11:17:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;回顾刚刚过去的2018年, 致海森, 也致他的博客.&lt;/p&gt;
&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;开始之前, 与各位分享一曲爵士. 请一边听着它, 一边往下读吧.&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>回顾刚刚过去的2018年, 致海森, 也致他的博客.</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>开始之前, 与各位分享一曲爵士. 请一边听着它, 一边往下读吧.<br><a id="more"></a></p><p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"></p><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script>const ap = new APlayer({    container: document.getElementById('aplayer'),    audio: [{        name: 'Concierto De Aranjuez',        artist: 'Chet Baker & Paul Desmond',        url:'https://img.vim-cn.com/7c/c5d8c3bc552e3254a70ae9d573a575e26e1f45.mp4',        cover: 'http://p1.music.126.net/KSpdMMTs5mMRRzq60hds6A==/724578162716416.jpg'    }]});</script><h2 id="独立博客的第一年"><a href="#独立博客的第一年" class="headerlink" title="独立博客的第一年"></a>独立博客的第一年</h2><p>其实真正的算起来, 开始写博客快有两年了. 最开始的时候在自己的VPS上搭建WordPress, 后来遭受过一次DDoS后就考虑着把平台迁移到GitHub Page. 事实上, 开始使用Hexo标志着我真正开始认真地写博客.</p><p>不过在建站之前, 我是没有写博客的习惯的. 之所以选择自己建立独立博客是因为第三方的平台上限制太多. 况且又有谁愿意把自己文字的命运和一个平台的生死捆绑在一起呢?</p><p>一开始写博客的时候, 我确信没有人会来看. 可能现在也没有. 即便有的话, 我写的文字也多是给搜索引擎的爬虫欣赏的. 孤独地写文字也绝非是什么坏事; 我自己的体验来看, 至少一个人写文字可以让我安静下来. 除了分享, 更多的时候是为了给自己在世界上留下一些痕迹, 偶尔回望的时候, 可以看见当年的自己. </p><p>当我在阅读CSAPP的时候, 我读到了<a href="https://wdxtub.com/" rel="external nofollow noopener noreferrer" target="_blank">小土刀</a>的系列笔记, 进而了解到他的博客. 他是我第一个钦佩的独立博客作者. 大概是从那以后, 我开始有了写自己的独立博客来分享技术和学习成果的念头. </p><p>不像平台, 独立博客没有导流, 流量全看质量. 亦无需紧盯着<code>visit</code>或是<code>follower</code>. 也很自由: 可以说该说的话, 可以做想做的事. </p><p>除了追求宁静, 毅然转向独立站还有一些外在的原因. 近年大环境日益恶化, 可是谁都没有想到这短短一年内竟然倒退成这个地步. 印象最深的是一日某乎更新其隐私政策, 用户可以点击同意或不同意; 选择不同意后重新回到选择界面, 直到用户被”同意”后才可以继续使用产品. 我在企鹅空间嘲讽这一无耻行径, 不料企鹅也是个流氓, 悄无声息的”消失”掉我的声音. </p><p>天下乌鸦是不是一般黑, 我不知道; 国内众厂商不但欺压用户, 往往还狼狈为奸的事实倒是一而再再而三的被实锤.</p><p>不管是自愿想找一个更好的环境, 还是无奈的出走, 总之种种原因让我选择了独立博客. 现在的我很庆幸这一决定.</p><h2 id="年度博文"><a href="#年度博文" class="headerlink" title="年度博文"></a>年度博文</h2><p>这里是今年自认为含金量比较高的几篇文章. 以后的文章(特别是技术文)的文风会向这些优质文章贴近.</p><ol><li><a href="https://hisenz.com/2018/11/02/%E6%B1%87%E7%BC%96%E8%A7%86%E8%A7%92-%E4%B8%8D%E5%90%8C%E4%BC%98%E5%8C%96%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84GCC%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/">汇编视角:不同优化级别下的GCC行为分析</a></li><li><a href="https://hisenz.com/2018/12/06/%E5%88%A9%E7%94%A8%E8%B6%8A%E7%95%8C%E5%92%8C%E6%BA%A2%E5%87%BA-C%E8%AF%AD%E8%A8%80/">利用越界和溢出:C语言</a></li><li><a href="https://hisenz.com/2018/04/20/%E9%81%93%E5%8F%AF%E9%81%93/">道可道 - 关于抽象和”道”的思考</a></li><li><a href="https://hisenz.com/2018/04/21/QR-Code/">二维码的抽象特征分析</a></li></ol><p>上半年开始了关于”道”的探究. 我认为”道”的观念里万物同源, “道”是最高的抽象, 由此”道可道,非常道”. 这种古老的东方哲学流派和计算机似乎存在着某种十分紧密的联系.</p><p>下半年最主要的学习内容是汇编和C语言. 私以为每个优秀的程序员都应该对整个计算机体系深入了解, 能擅长Python也能写汇编, 对于硬件电路的工作原理了然于心. 成为一个优秀的programmer, 我还有很长的路要走.</p><h2 id="关于博客的2019"><a href="#关于博客的2019" class="headerlink" title="关于博客的2019"></a>关于博客的2019</h2><p>在写下这篇文章之前, Hisen’s Blog主要关注技术文和一些个人思考. 接下来的一年里我打算增强这个博客的分享属性. 之后的内容大致分为四块:</p><ol><li>技术文/学习贴</li><li>音乐/乐评</li><li>料理</li><li>生活/思考</li></ol><p>计划里新增的category如下:</p><h3 id="1-增加音乐的推荐-amp-乐评"><a href="#1-增加音乐的推荐-amp-乐评" class="headerlink" title="1. 增加音乐的推荐 &amp; 乐评"></a>1. 增加音乐的推荐 &amp; 乐评</h3><p>我想, 大概会新增一些爵士音乐的分享. 从Louis Armstrong到Terry Callier, 爵士乐在历史上有很多好的作品, 即便在当代也是一样. 许多优秀的作品被传唱演绎了近一百年, 这绝不是今天某些当红的流量明星所能享有的荣耀. 如果我的努力能把大多数国人的审美提高哪怕一点点, 我也是很高兴的.</p><p>爵士是浪漫的, 爵士也是绝望的. 爵士离不开misty. 这也是爵士如此吸引人的原因.</p><p>Hisen’s Blog的早期曾有一些爵士乐评, 可惜在一次事故中丢失了. 说是乐评, 那些文章看起来更像是”大段的推荐描述性文字”. 接下来的一年里, 我将尝试在这个方向上取得一些突破.</p><h3 id="2-增加料理板块"><a href="#2-增加料理板块" class="headerlink" title="2. 增加料理板块"></a>2. 增加料理板块</h3><p>我对食物和烹饪抱有极大的兴趣. 这可能继承自家父. </p><p>在目前的设想里, 这个板块里面主要以图文的形式呈现西餐食物及制作, 不定期的也会收集一些学习资源共享出来. 大多数国人认为西餐的式样和制作都简单, 可能是由于美国快餐文化带来的影响所致. 事实上整个欧洲在过去的数千年内积累下来的餐饮学问和中餐一样博大精深; 从某些层面看, 西餐的细节把控较中式餐点更为严格. </p><p>例如美式早餐的代表<code>Egg Benedict</code>的构成很简单:一片”面包”, 一块”培根”, 一只溏心蛋和荷兰酱. 但是作为”面包”的<code>Muffin</code>分为英式和美式(事实上它是蛋糕的一种); 使用到的培根也是一种火腿; 荷兰酱必须现做, 制作的过程也需要精细控制温度. 假如处理不当, 做出来的<code>Hollandaise Sauce</code>会有蛋腥味.</p><p>分享美食的制作过程和美食本身一样令人愉悦. </p><h3 id="3-修改生活板块"><a href="#3-修改生活板块" class="headerlink" title="3. 修改生活板块"></a>3. 修改生活板块</h3><p>过去这个分类下往往包含了自己的思考和一些对时事的看法. 现在它也将囊括一些Life Hacking的内容. 目前有计划打算低成本实现一台舒肥机, 或许过不久它就会出现在我的博文里.</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>余下的时间里, 继续享受爵士乐大师们的作品吧 : )</p>]]></content:encoded>
      
      <comments>https://hisenz.com/post/2018-summary/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
